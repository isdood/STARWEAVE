/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../../deps/phoenix/priv/static/phoenix.mjs":
/*!*****************************************************!*\
  !*** ../../../deps/phoenix/priv/static/phoenix.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Channel: () => (/* binding */ Channel),\n/* harmony export */   LongPoll: () => (/* binding */ LongPoll),\n/* harmony export */   Presence: () => (/* binding */ Presence),\n/* harmony export */   Serializer: () => (/* binding */ serializer_default),\n/* harmony export */   Socket: () => (/* binding */ Socket)\n/* harmony export */ });\n// js/phoenix/utils.js\nvar closure = (value) => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure2 = function() {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || globalThis;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\nvar XHR_STATES = {\n  complete: 4\n};\nvar AUTH_TOKEN_PREFIX = \"base64url.bearer.phx.\";\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function() {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  /**\n   *\n   * @param {number} timeout\n   */\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  /**\n   *\n   */\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  /**\n   * @private\n   */\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  /**\n   * @private\n   */\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  /**\n   * @private\n   */\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  /**\n   * @private\n   */\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  /**\n   * @private\n   */\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  /**\n   * @private\n   */\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  /**\n   * @private\n   */\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(\n      this.socket.onOpen(() => {\n        this.rejoinTimer.reset();\n        if (this.isErrored()) {\n          this.rejoin();\n        }\n      })\n    );\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason) => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n  }\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  /**\n   * Unsubscribes off of channel events\n   *\n   * Use the ref returned from a channel.on() to unsubscribe one\n   * handler, or pass nothing for the ref to unsubscribe all\n   * handlers for the given event.\n   *\n   * @example\n   * // Unsubscribe the do_stuff handler\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * channel.off(\"event\", ref1)\n   *\n   * // Unsubscribe all handlers from event\n   * channel.off(\"event\")\n   *\n   * @param {string} event\n   * @param {integer} ref\n   */\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  /**\n   * @private\n   */\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  /**\n   * Sends a message `event` to phoenix with the payload `payload`.\n   * Phoenix receives this in the `handle_in(event, payload, socket)`\n   * function. if phoenix replies or it times out (default 10000ms),\n   * then optionally the reply can be received.\n   *\n   * @example\n   * channel.push(\"event\")\n   *   .receive(\"ok\", payload => console.log(\"phoenix replied:\", payload))\n   *   .receive(\"error\", err => console.log(\"phoenix errored\", err))\n   *   .receive(\"timeout\", () => console.log(\"timed out pushing\"))\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function() {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n    return leavePush;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /**\n   * @private\n   */\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * @private\n   */\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  /**\n   * @private\n   */\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /**\n   * @private\n   */\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  /**\n   * @private\n   */\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /**\n   * @private\n   */\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /**\n   * @private\n   */\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  /**\n   * @private\n   */\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /**\n   * @private\n   */\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /**\n   * @private\n   */\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, headers, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else if (global.XMLHttpRequest) {\n      let req = new global.XMLHttpRequest();\n      return this.xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback);\n    } else if (global.fetch && global.AbortController) {\n      return this.fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback);\n    } else {\n      throw new Error(\"No suitable XMLHttpRequest implementation found\");\n    }\n  }\n  static fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback) {\n    let options = {\n      method,\n      headers,\n      body\n    };\n    let controller = null;\n    if (timeout) {\n      controller = new AbortController();\n      const _timeoutId = setTimeout(() => controller.abort(), timeout);\n      options.signal = controller.signal;\n    }\n    global.fetch(endPoint, options).then((response) => response.text()).then((data) => this.parseJSON(data)).then((data) => callback && callback(data)).catch((err) => {\n      if (err.name === \"AbortError\" && ontimeout) {\n        ontimeout();\n      } else {\n        callback && callback(null);\n      }\n    });\n    return controller;\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {\n    };\n    req.send(body);\n    return req;\n  }\n  static xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    for (let [key, value] of Object.entries(headers)) {\n      req.setRequestHeader(key, value);\n    }\n    req.onerror = () => callback && callback(null);\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n    return req;\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar arrayBufferToBase64 = (buffer) => {\n  let binary = \"\";\n  let bytes = new Uint8Array(buffer);\n  let len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n};\nvar LongPoll = class {\n  constructor(endPoint, protocols) {\n    if (protocols && protocols.length === 2 && protocols[1].startsWith(AUTH_TOKEN_PREFIX)) {\n      this.authToken = atob(protocols[1].slice(AUTH_TOKEN_PREFIX.length));\n    }\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.reqs = /* @__PURE__ */ new Set();\n    this.awaitingBatchAck = false;\n    this.currentBatch = null;\n    this.currentBatchTimer = null;\n    this.batchBuffer = [];\n    this.onopen = function() {\n    };\n    this.onerror = function() {\n    };\n    this.onmessage = function() {\n    };\n    this.onclose = function() {\n    };\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    setTimeout(() => this.poll(), 0);\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry(code, reason, wasClean) {\n    this.close(code, reason, wasClean);\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry(1005, \"timeout\", false);\n  }\n  isActive() {\n    return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;\n  }\n  poll() {\n    const headers = { \"Accept\": \"application/json\" };\n    if (this.authToken) {\n      headers[\"X-Phoenix-AuthToken\"] = this.authToken;\n    }\n    this.ajax(\"GET\", headers, null, () => this.ontimeout(), (resp) => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach((msg) => {\n            setTimeout(() => this.onmessage({ data: msg }), 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen({});\n          this.poll();\n          break;\n        case 403:\n          this.onerror(403);\n          this.close(1008, \"forbidden\", false);\n          break;\n        case 0:\n        case 500:\n          this.onerror(500);\n          this.closeAndRetry(1011, \"internal server error\", 500);\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  // we collect all pushes within the current event loop by\n  // setTimeout 0, which optimizes back-to-back procedural\n  // pushes against an empty buffer\n  send(body) {\n    if (typeof body !== \"string\") {\n      body = arrayBufferToBase64(body);\n    }\n    if (this.currentBatch) {\n      this.currentBatch.push(body);\n    } else if (this.awaitingBatchAck) {\n      this.batchBuffer.push(body);\n    } else {\n      this.currentBatch = [body];\n      this.currentBatchTimer = setTimeout(() => {\n        this.batchSend(this.currentBatch);\n        this.currentBatch = null;\n      }, 0);\n    }\n  }\n  batchSend(messages) {\n    this.awaitingBatchAck = true;\n    this.ajax(\"POST\", { \"Content-Type\": \"application/x-ndjson\" }, messages.join(\"\\n\"), () => this.onerror(\"timeout\"), (resp) => {\n      this.awaitingBatchAck = false;\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry(1011, \"internal server error\", false);\n      } else if (this.batchBuffer.length > 0) {\n        this.batchSend(this.batchBuffer);\n        this.batchBuffer = [];\n      }\n    });\n  }\n  close(code, reason, wasClean) {\n    for (let req of this.reqs) {\n      req.abort();\n    }\n    this.readyState = SOCKET_STATES.closed;\n    let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });\n    this.batchBuffer = [];\n    clearTimeout(this.currentBatchTimer);\n    this.currentBatchTimer = null;\n    if (typeof CloseEvent !== \"undefined\") {\n      this.onclose(new CloseEvent(\"close\", opts));\n    } else {\n      this.onclose(opts);\n    }\n  }\n  ajax(method, headers, body, onCallerTimeout, callback) {\n    let req;\n    let ontimeout = () => {\n      this.reqs.delete(req);\n      onCallerTimeout();\n    };\n    req = Ajax.request(method, this.endpointURL(), headers, body, this.timeout, ontimeout, (resp) => {\n      this.reqs.delete(req);\n      if (this.isActive()) {\n        callback(resp);\n      }\n    });\n    this.reqs.add(req);\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function() {\n      },\n      onLeave: function() {\n      },\n      onSync: function() {\n      }\n    };\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  // lower-level public static API\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function() {\n      };\n    }\n    if (!onLeave) {\n      onLeave = function() {\n      };\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function(key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  // private\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  // private\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.primaryPassedHealthCheck = false;\n    this.longPollFallbackMs = opts.longPollFallbackMs;\n    this.fallbackTimer = null;\n    this.sessionStore = opts.sessionStorage || global && global.sessionStorage;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.disconnecting = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", (_e) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    if (!this.logger && opts.debug) {\n      this.logger = (kind, msg, data) => {\n        console.log(`${kind}: ${msg}`, data);\n      };\n    }\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimeoutTimer = null;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n    this.authToken = opts.authToken;\n  }\n  /**\n   * Returns the LongPoll transport reference\n   */\n  getLongPollTransport() {\n    return LongPoll;\n  }\n  /**\n   * Disconnects and replaces the active transport\n   *\n   * @param {Function} newTransport - The new transport class to instantiate\n   *\n   */\n  replaceTransport(newTransport) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    clearTimeout(this.fallbackTimer);\n    this.reconnectTimer.reset();\n    if (this.conn) {\n      this.conn.close();\n      this.conn = null;\n    }\n    this.transport = newTransport;\n  }\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  /**\n   * The fully qualified socket url\n   *\n   * @returns {string}\n   */\n  endPointURL() {\n    let uri = Ajax.appendParams(\n      Ajax.appendParams(this.endPoint, this.params()),\n      { vsn: this.vsn }\n    );\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  /**\n   * Disconnects the socket\n   *\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.\n   *\n   * @param {Function} callback - Optional callback which is called after socket is disconnected.\n   * @param {integer} code - A status code for disconnection (Optional).\n   * @param {string} reason - A textual description of the reason to disconnect. (Optional)\n   */\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.disconnecting = true;\n    this.closeWasClean = true;\n    clearTimeout(this.fallbackTimer);\n    this.reconnectTimer.reset();\n    this.teardown(() => {\n      this.disconnecting = false;\n      callback && callback();\n    }, code, reason);\n  }\n  /**\n   *\n   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n   *\n   * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n   * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n   */\n  connect(params) {\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n    if (this.conn && !this.disconnecting) {\n      return;\n    }\n    if (this.longPollFallbackMs && this.transport !== LongPoll) {\n      this.connectWithFallback(LongPoll, this.longPollFallbackMs);\n    } else {\n      this.transportConnect();\n    }\n  }\n  /**\n   * Logs the message. Override `this.logger` for specialized logging. noops by default\n   * @param {string} kind\n   * @param {string} msg\n   * @param {Object} data\n   */\n  log(kind, msg, data) {\n    this.logger && this.logger(kind, msg, data);\n  }\n  /**\n   * Returns true if a logger has been set on this socket.\n   */\n  hasLogger() {\n    return this.logger !== null;\n  }\n  /**\n   * Registers callbacks for connection open events\n   *\n   * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n   *\n   * @param {Function} callback\n   */\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  /**\n   * Registers callbacks for connection close events\n   * @param {Function} callback\n   */\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  /**\n   * Registers callbacks for connection error events\n   *\n   * @example socket.onError(function(error){ alert(\"An error occurred\") })\n   *\n   * @param {Function} callback\n   */\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  /**\n   * Registers callbacks for connection message events\n   * @param {Function} callback\n   */\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  /**\n   * Pings the server and invokes the callback with the RTT in milliseconds\n   * @param {Function} callback\n   *\n   * Returns true if the ping was pushed or false if unable to be pushed.\n   */\n  ping(callback) {\n    if (!this.isConnected()) {\n      return false;\n    }\n    let ref = this.makeRef();\n    let startTime = Date.now();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref });\n    let onMsgRef = this.onMessage((msg) => {\n      if (msg.ref === ref) {\n        this.off([onMsgRef]);\n        callback(Date.now() - startTime);\n      }\n    });\n    return true;\n  }\n  /**\n   * @private\n   */\n  transportConnect() {\n    this.connectClock++;\n    this.closeWasClean = false;\n    let protocols = void 0;\n    if (this.authToken) {\n      protocols = [\"phoenix\", `${AUTH_TOKEN_PREFIX}${btoa(this.authToken).replace(/=/g, \"\")}`];\n    }\n    this.conn = new this.transport(this.endPointURL(), protocols);\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n  getSession(key) {\n    return this.sessionStore && this.sessionStore.getItem(key);\n  }\n  storeSession(key, val) {\n    this.sessionStore && this.sessionStore.setItem(key, val);\n  }\n  connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {\n    clearTimeout(this.fallbackTimer);\n    let established = false;\n    let primaryTransport = true;\n    let openRef, errorRef;\n    let fallback = (reason) => {\n      this.log(\"transport\", `falling back to ${fallbackTransport.name}...`, reason);\n      this.off([openRef, errorRef]);\n      primaryTransport = false;\n      this.replaceTransport(fallbackTransport);\n      this.transportConnect();\n    };\n    if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {\n      return fallback(\"memorized\");\n    }\n    this.fallbackTimer = setTimeout(fallback, fallbackThreshold);\n    errorRef = this.onError((reason) => {\n      this.log(\"transport\", \"error\", reason);\n      if (primaryTransport && !established) {\n        clearTimeout(this.fallbackTimer);\n        fallback(reason);\n      }\n    });\n    this.onOpen(() => {\n      established = true;\n      if (!primaryTransport) {\n        if (!this.primaryPassedHealthCheck) {\n          this.storeSession(`phx:fallback:${fallbackTransport.name}`, \"true\");\n        }\n        return this.log(\"transport\", `established ${fallbackTransport.name} fallback`);\n      }\n      clearTimeout(this.fallbackTimer);\n      this.fallbackTimer = setTimeout(fallback, fallbackThreshold);\n      this.ping((rtt) => {\n        this.log(\"transport\", \"connected to primary after\", rtt);\n        this.primaryPassedHealthCheck = true;\n        clearTimeout(this.fallbackTimer);\n      });\n    });\n    this.transportConnect();\n  }\n  clearHeartbeats() {\n    clearTimeout(this.heartbeatTimer);\n    clearTimeout(this.heartbeatTimeoutTimer);\n  }\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log(\"transport\", `${this.transport.name} connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.disconnecting = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  /**\n   * @private\n   */\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      }\n      this.triggerChanError();\n      this.closeWasClean = false;\n      this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, \"heartbeat timeout\");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    this.clearHeartbeats();\n    this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    let connectClock = this.connectClock;\n    this.waitForBufferDone(() => {\n      if (connectClock !== this.connectClock) {\n        return;\n      }\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (connectClock !== this.connectClock) {\n          return;\n        }\n        if (this.conn) {\n          this.conn.onopen = function() {\n          };\n          this.conn.onerror = function() {\n          };\n          this.conn.onmessage = function() {\n          };\n          this.conn.onclose = function() {\n          };\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    let closeCode = event && event.code;\n    if (this.hasLogger())\n      this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    this.clearHeartbeats();\n    if (!this.closeWasClean && closeCode !== 1e3) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  /**\n   * @private\n   */\n  onConnError(error) {\n    if (this.hasLogger())\n      this.log(\"transport\", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  /**\n   * @private\n   */\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  /**\n   * @returns {string}\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n  /**\n   * @returns {boolean}\n   */\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  /**\n   * @private\n   *\n   * @param {Channel}\n   */\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c !== channel);\n  }\n  /**\n   * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.\n   *\n   * @param {refs} - list of refs returned by calls to\n   *                 `onOpen`, `onClose`, `onError,` and `onMessage`\n   */\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  /**\n   * Initiates a new channel for the given topic\n   *\n   * @param {string} topic\n   * @param {Object} chanParams - Parameters for the channel\n   * @returns {Channel}\n   */\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * @param {Object} data\n   */\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\n    }\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   * @returns {string}\n   */\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.clearHeartbeats();\n        this.pendingHeartbeatRef = null;\n        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger())\n        this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n};\n\n//# sourceMappingURL=phoenix.mjs.map\n\n\n//# sourceURL=webpack://starweave_web/../../../deps/phoenix/priv/static/phoenix.mjs?\n}");

/***/ }),

/***/ "../../../deps/phoenix_html/priv/static/phoenix_html.js":
/*!**************************************************************!*\
  !*** ../../../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \**************************************************************/
/***/ (() => {

eval("{\n\n(function() {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent;\n    // IE<=9 Support\n    function CustomEvent(event, params) {\n      params = params || {bubbles: false, cancelable: false, detail: undefined};\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        submit = document.createElement(\"input\"),\n        target = element.getAttribute(\"target\");\n\n    form.method = (element.getAttribute(\"data-method\") === \"get\") ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"none\";\n\n    if (target) form.target = target;\n    else if (targetModifierKey) form.target = \"_blank\";\n\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n\n    // Insert a button and click it instead of using `form.submit`\n    // because the `submit` function does not emit a `submit` event.\n    submit.type = \"submit\";\n    form.appendChild(submit);\n    submit.click();\n  }\n\n  window.addEventListener(\"click\", function(e) {\n    var element = e.target;\n    if (e.defaultPrevented) return;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true, \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\") && element.getAttribute(\"data-to\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n    if(message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();\n\n\n//# sourceURL=webpack://starweave_web/../../../deps/phoenix_html/priv/static/phoenix_html.js?\n}");

/***/ }),

/***/ "../../../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js":
/*!****************************************************************************!*\
  !*** ../../../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveSocket: () => (/* binding */ LiveSocket2),\n/* harmony export */   ViewHook: () => (/* binding */ ViewHook),\n/* harmony export */   createHook: () => (/* binding */ createHook),\n/* harmony export */   isUsedInput: () => (/* binding */ isUsedInput)\n/* harmony export */ });\n// js/phoenix_live_view/constants.js\nvar CONSECUTIVE_RELOADS = \"consecutive-reloads\";\nvar MAX_RELOADS = 10;\nvar RELOAD_JITTER_MIN = 5e3;\nvar RELOAD_JITTER_MAX = 1e4;\nvar FAILSAFE_JITTER = 3e4;\nvar PHX_EVENT_CLASSES = [\n  \"phx-click-loading\",\n  \"phx-change-loading\",\n  \"phx-submit-loading\",\n  \"phx-keydown-loading\",\n  \"phx-keyup-loading\",\n  \"phx-blur-loading\",\n  \"phx-focus-loading\",\n  \"phx-hook-loading\"\n];\nvar PHX_COMPONENT = \"data-phx-component\";\nvar PHX_VIEW_REF = \"data-phx-view\";\nvar PHX_LIVE_LINK = \"data-phx-link\";\nvar PHX_TRACK_STATIC = \"track-static\";\nvar PHX_LINK_STATE = \"data-phx-link-state\";\nvar PHX_REF_LOADING = \"data-phx-ref-loading\";\nvar PHX_REF_SRC = \"data-phx-ref-src\";\nvar PHX_REF_LOCK = \"data-phx-ref-lock\";\nvar PHX_PENDING_REFS = \"phx-pending-refs\";\nvar PHX_TRACK_UPLOADS = \"track-uploads\";\nvar PHX_UPLOAD_REF = \"data-phx-upload-ref\";\nvar PHX_PREFLIGHTED_REFS = \"data-phx-preflighted-refs\";\nvar PHX_DONE_REFS = \"data-phx-done-refs\";\nvar PHX_DROP_TARGET = \"drop-target\";\nvar PHX_ACTIVE_ENTRY_REFS = \"data-phx-active-refs\";\nvar PHX_LIVE_FILE_UPDATED = \"phx:live-file:updated\";\nvar PHX_SKIP = \"data-phx-skip\";\nvar PHX_MAGIC_ID = \"data-phx-id\";\nvar PHX_PRUNE = \"data-phx-prune\";\nvar PHX_CONNECTED_CLASS = \"phx-connected\";\nvar PHX_LOADING_CLASS = \"phx-loading\";\nvar PHX_ERROR_CLASS = \"phx-error\";\nvar PHX_CLIENT_ERROR_CLASS = \"phx-client-error\";\nvar PHX_SERVER_ERROR_CLASS = \"phx-server-error\";\nvar PHX_PARENT_ID = \"data-phx-parent-id\";\nvar PHX_MAIN = \"data-phx-main\";\nvar PHX_ROOT_ID = \"data-phx-root-id\";\nvar PHX_VIEWPORT_TOP = \"viewport-top\";\nvar PHX_VIEWPORT_BOTTOM = \"viewport-bottom\";\nvar PHX_TRIGGER_ACTION = \"trigger-action\";\nvar PHX_HAS_FOCUSED = \"phx-has-focused\";\nvar FOCUSABLE_INPUTS = [\n  \"text\",\n  \"textarea\",\n  \"number\",\n  \"email\",\n  \"password\",\n  \"search\",\n  \"tel\",\n  \"url\",\n  \"date\",\n  \"time\",\n  \"datetime-local\",\n  \"color\",\n  \"range\"\n];\nvar CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\nvar PHX_HAS_SUBMITTED = \"phx-has-submitted\";\nvar PHX_SESSION = \"data-phx-session\";\nvar PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;\nvar PHX_STICKY = \"data-phx-sticky\";\nvar PHX_STATIC = \"data-phx-static\";\nvar PHX_READONLY = \"data-phx-readonly\";\nvar PHX_DISABLED = \"data-phx-disabled\";\nvar PHX_DISABLE_WITH = \"disable-with\";\nvar PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\nvar PHX_HOOK = \"hook\";\nvar PHX_DEBOUNCE = \"debounce\";\nvar PHX_THROTTLE = \"throttle\";\nvar PHX_UPDATE = \"update\";\nvar PHX_STREAM = \"stream\";\nvar PHX_STREAM_REF = \"data-phx-stream\";\nvar PHX_PORTAL = \"data-phx-portal\";\nvar PHX_TELEPORTED_REF = \"data-phx-teleported\";\nvar PHX_TELEPORTED_SRC = \"data-phx-teleported-src\";\nvar PHX_RUNTIME_HOOK = \"data-phx-runtime-hook\";\nvar PHX_LV_PID = \"data-phx-pid\";\nvar PHX_KEY = \"key\";\nvar PHX_PRIVATE = \"phxPrivate\";\nvar PHX_AUTO_RECOVER = \"auto-recover\";\nvar PHX_LV_DEBUG = \"phx:live-socket:debug\";\nvar PHX_LV_PROFILE = \"phx:live-socket:profiling\";\nvar PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\nvar PHX_LV_HISTORY_POSITION = \"phx:nav-history-position\";\nvar PHX_PROGRESS = \"progress\";\nvar PHX_MOUNTED = \"mounted\";\nvar PHX_RELOAD_STATUS = \"__phoenix_reload_status__\";\nvar LOADER_TIMEOUT = 1;\nvar MAX_CHILD_JOIN_ATTEMPTS = 3;\nvar BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\nvar DISCONNECTED_TIMEOUT = 500;\nvar BINDING_PREFIX = \"phx-\";\nvar PUSH_TIMEOUT = 3e4;\nvar DEBOUNCE_TRIGGER = \"debounce-trigger\";\nvar THROTTLED = \"throttled\";\nvar DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\nvar DEFAULTS = {\n  debounce: 300,\n  throttle: 300\n};\nvar PHX_PENDING_ATTRS = [PHX_REF_LOADING, PHX_REF_SRC, PHX_REF_LOCK];\nvar STATIC = \"s\";\nvar ROOT = \"r\";\nvar COMPONENTS = \"c\";\nvar KEYED = \"k\";\nvar KEYED_COUNT = \"kc\";\nvar EVENTS = \"e\";\nvar REPLY = \"r\";\nvar TITLE = \"t\";\nvar TEMPLATES = \"p\";\nvar STREAM = \"stream\";\n\n// js/phoenix_live_view/entry_uploader.js\nvar EntryUploader = class {\n  constructor(entry, config, liveSocket) {\n    const { chunk_size, chunk_timeout } = config;\n    this.liveSocket = liveSocket;\n    this.entry = entry;\n    this.offset = 0;\n    this.chunkSize = chunk_size;\n    this.chunkTimeout = chunk_timeout;\n    this.chunkTimer = null;\n    this.errored = false;\n    this.uploadChannel = liveSocket.channel(`lvu:${entry.ref}`, {\n      token: entry.metadata()\n    });\n  }\n  error(reason) {\n    if (this.errored) {\n      return;\n    }\n    this.uploadChannel.leave();\n    this.errored = true;\n    clearTimeout(this.chunkTimer);\n    this.entry.error(reason);\n  }\n  upload() {\n    this.uploadChannel.onError((reason) => this.error(reason));\n    this.uploadChannel.join().receive(\"ok\", (_data) => this.readNextChunk()).receive(\"error\", (reason) => this.error(reason));\n  }\n  isDone() {\n    return this.offset >= this.entry.file.size;\n  }\n  readNextChunk() {\n    const reader = new window.FileReader();\n    const blob = this.entry.file.slice(\n      this.offset,\n      this.chunkSize + this.offset\n    );\n    reader.onload = (e) => {\n      if (e.target.error === null) {\n        this.offset += /** @type {ArrayBuffer} */\n        e.target.result.byteLength;\n        this.pushChunk(\n          /** @type {ArrayBuffer} */\n          e.target.result\n        );\n      } else {\n        return logError(\"Read error: \" + e.target.error);\n      }\n    };\n    reader.readAsArrayBuffer(blob);\n  }\n  pushChunk(chunk) {\n    if (!this.uploadChannel.isJoined()) {\n      return;\n    }\n    this.uploadChannel.push(\"chunk\", chunk, this.chunkTimeout).receive(\"ok\", () => {\n      this.entry.progress(this.offset / this.entry.file.size * 100);\n      if (!this.isDone()) {\n        this.chunkTimer = setTimeout(\n          () => this.readNextChunk(),\n          this.liveSocket.getLatencySim() || 0\n        );\n      }\n    }).receive(\"error\", ({ reason }) => this.error(reason));\n  }\n};\n\n// js/phoenix_live_view/utils.js\nvar logError = (msg, obj) => console.error && console.error(msg, obj);\nvar isCid = (cid) => {\n  const type = typeof cid;\n  return type === \"number\" || type === \"string\" && /^(0|[1-9]\\d*)$/.test(cid);\n};\nfunction detectDuplicateIds() {\n  const ids = /* @__PURE__ */ new Set();\n  const elems = document.querySelectorAll(\"*[id]\");\n  for (let i = 0, len = elems.length; i < len; i++) {\n    if (ids.has(elems[i].id)) {\n      console.error(\n        `Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`\n      );\n    } else {\n      ids.add(elems[i].id);\n    }\n  }\n}\nfunction detectInvalidStreamInserts(inserts) {\n  const errors = /* @__PURE__ */ new Set();\n  Object.keys(inserts).forEach((id) => {\n    const streamEl = document.getElementById(id);\n    if (streamEl && streamEl.parentElement && streamEl.parentElement.getAttribute(\"phx-update\") !== \"stream\") {\n      errors.add(\n        `The stream container with id \"${streamEl.parentElement.id}\" is missing the phx-update=\"stream\" attribute. Ensure it is set for streams to work properly.`\n      );\n    }\n  });\n  errors.forEach((error) => console.error(error));\n}\nvar debug = (view, kind, msg, obj) => {\n  if (view.liveSocket.isDebugEnabled()) {\n    console.log(`${view.id} ${kind}: ${msg} - `, obj);\n  }\n};\nvar closure = (val) => typeof val === \"function\" ? val : function() {\n  return val;\n};\nvar clone = (obj) => {\n  return JSON.parse(JSON.stringify(obj));\n};\nvar closestPhxBinding = (el, binding, borderEl) => {\n  do {\n    if (el.matches(`[${binding}]`) && !el.disabled) {\n      return el;\n    }\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));\n  return null;\n};\nvar isObject = (obj) => {\n  return obj !== null && typeof obj === \"object\" && !(obj instanceof Array);\n};\nvar isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);\nvar isEmpty = (obj) => {\n  for (const x in obj) {\n    return false;\n  }\n  return true;\n};\nvar maybe = (el, callback) => el && callback(el);\nvar channelUploader = function(entries, onError, resp, liveSocket) {\n  entries.forEach((entry) => {\n    const entryUploader = new EntryUploader(entry, resp.config, liveSocket);\n    entryUploader.upload();\n  });\n};\n\n// js/phoenix_live_view/browser.js\nvar Browser = {\n  canPushState() {\n    return typeof history.pushState !== \"undefined\";\n  },\n  dropLocal(localStorage, namespace, subkey) {\n    return localStorage.removeItem(this.localKey(namespace, subkey));\n  },\n  updateLocal(localStorage, namespace, subkey, initial, func) {\n    const current = this.getLocal(localStorage, namespace, subkey);\n    const key = this.localKey(namespace, subkey);\n    const newVal = current === null ? initial : func(current);\n    localStorage.setItem(key, JSON.stringify(newVal));\n    return newVal;\n  },\n  getLocal(localStorage, namespace, subkey) {\n    return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));\n  },\n  updateCurrentState(callback) {\n    if (!this.canPushState()) {\n      return;\n    }\n    history.replaceState(\n      callback(history.state || {}),\n      \"\",\n      window.location.href\n    );\n  },\n  pushState(kind, meta, to) {\n    if (this.canPushState()) {\n      if (to !== window.location.href) {\n        if (meta.type == \"redirect\" && meta.scroll) {\n          const currentState = history.state || {};\n          currentState.scroll = meta.scroll;\n          history.replaceState(currentState, \"\", window.location.href);\n        }\n        delete meta.scroll;\n        history[kind + \"State\"](meta, \"\", to || null);\n        window.requestAnimationFrame(() => {\n          const hashEl = this.getHashTargetEl(window.location.hash);\n          if (hashEl) {\n            hashEl.scrollIntoView();\n          } else if (meta.type === \"redirect\") {\n            window.scroll(0, 0);\n          }\n        });\n      }\n    } else {\n      this.redirect(to);\n    }\n  },\n  setCookie(name, value, maxAgeSeconds) {\n    const expires = typeof maxAgeSeconds === \"number\" ? ` max-age=${maxAgeSeconds};` : \"\";\n    document.cookie = `${name}=${value};${expires} path=/`;\n  },\n  getCookie(name) {\n    return document.cookie.replace(\n      new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`),\n      \"$1\"\n    );\n  },\n  deleteCookie(name) {\n    document.cookie = `${name}=; max-age=-1; path=/`;\n  },\n  redirect(toURL, flash, navigate = (url) => {\n    window.location.href = url;\n  }) {\n    if (flash) {\n      this.setCookie(\"__phoenix_flash__\", flash, 60);\n    }\n    navigate(toURL);\n  },\n  localKey(namespace, subkey) {\n    return `${namespace}-${subkey}`;\n  },\n  getHashTargetEl(maybeHash) {\n    const hash = maybeHash.toString().substring(1);\n    if (hash === \"\") {\n      return;\n    }\n    return document.getElementById(hash) || document.querySelector(`a[name=\"${hash}\"]`);\n  }\n};\nvar browser_default = Browser;\n\n// js/phoenix_live_view/dom.js\nvar DOM = {\n  byId(id) {\n    return document.getElementById(id) || logError(`no id found for ${id}`);\n  },\n  removeClass(el, className) {\n    el.classList.remove(className);\n    if (el.classList.length === 0) {\n      el.removeAttribute(\"class\");\n    }\n  },\n  all(node, query, callback) {\n    if (!node) {\n      return [];\n    }\n    const array = Array.from(node.querySelectorAll(query));\n    if (callback) {\n      array.forEach(callback);\n    }\n    return array;\n  },\n  childNodeLength(html) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    return template.content.childElementCount;\n  },\n  isUploadInput(el) {\n    return el.type === \"file\" && el.getAttribute(PHX_UPLOAD_REF) !== null;\n  },\n  isAutoUpload(inputEl) {\n    return inputEl.hasAttribute(\"data-phx-auto-upload\");\n  },\n  findUploadInputs(node) {\n    const formId = node.id;\n    const inputsOutsideForm = this.all(\n      document,\n      `input[type=\"file\"][${PHX_UPLOAD_REF}][form=\"${formId}\"]`\n    );\n    return this.all(node, `input[type=\"file\"][${PHX_UPLOAD_REF}]`).concat(\n      inputsOutsideForm\n    );\n  },\n  findComponentNodeList(viewId, cid, doc2 = document) {\n    return this.all(\n      doc2,\n      `[${PHX_VIEW_REF}=\"${viewId}\"][${PHX_COMPONENT}=\"${cid}\"]`\n    );\n  },\n  isPhxDestroyed(node) {\n    return node.id && DOM.private(node, \"destroyed\") ? true : false;\n  },\n  wantsNewTab(e) {\n    const wantsNewTab = e.ctrlKey || e.shiftKey || e.metaKey || e.button && e.button === 1;\n    const isDownload = e.target instanceof HTMLAnchorElement && e.target.hasAttribute(\"download\");\n    const isTargetBlank = e.target.hasAttribute(\"target\") && e.target.getAttribute(\"target\").toLowerCase() === \"_blank\";\n    const isTargetNamedTab = e.target.hasAttribute(\"target\") && !e.target.getAttribute(\"target\").startsWith(\"_\");\n    return wantsNewTab || isTargetBlank || isDownload || isTargetNamedTab;\n  },\n  isUnloadableFormSubmit(e) {\n    const isDialogSubmit = e.target && e.target.getAttribute(\"method\") === \"dialog\" || e.submitter && e.submitter.getAttribute(\"formmethod\") === \"dialog\";\n    if (isDialogSubmit) {\n      return false;\n    } else {\n      return !e.defaultPrevented && !this.wantsNewTab(e);\n    }\n  },\n  isNewPageClick(e, currentLocation) {\n    const href = e.target instanceof HTMLAnchorElement ? e.target.getAttribute(\"href\") : null;\n    let url;\n    if (e.defaultPrevented || href === null || this.wantsNewTab(e)) {\n      return false;\n    }\n    if (href.startsWith(\"mailto:\") || href.startsWith(\"tel:\")) {\n      return false;\n    }\n    if (e.target.isContentEditable) {\n      return false;\n    }\n    try {\n      url = new URL(href);\n    } catch {\n      try {\n        url = new URL(href, currentLocation);\n      } catch {\n        return true;\n      }\n    }\n    if (url.host === currentLocation.host && url.protocol === currentLocation.protocol) {\n      if (url.pathname === currentLocation.pathname && url.search === currentLocation.search) {\n        return url.hash === \"\" && !url.href.endsWith(\"#\");\n      }\n    }\n    return url.protocol.startsWith(\"http\");\n  },\n  markPhxChildDestroyed(el) {\n    if (this.isPhxChild(el)) {\n      el.setAttribute(PHX_SESSION, \"\");\n    }\n    this.putPrivate(el, \"destroyed\", true);\n  },\n  findPhxChildrenInFragment(html, parentId) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    return this.findPhxChildren(template.content, parentId);\n  },\n  isIgnored(el, phxUpdate) {\n    return (el.getAttribute(phxUpdate) || el.getAttribute(\"data-phx-update\")) === \"ignore\";\n  },\n  isPhxUpdate(el, phxUpdate, updateTypes) {\n    return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;\n  },\n  findPhxSticky(el) {\n    return this.all(el, `[${PHX_STICKY}]`);\n  },\n  findPhxChildren(el, parentId) {\n    return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${parentId}\"]`);\n  },\n  findExistingParentCIDs(viewId, cids) {\n    const parentCids = /* @__PURE__ */ new Set();\n    const childrenCids = /* @__PURE__ */ new Set();\n    cids.forEach((cid) => {\n      this.all(\n        document,\n        `[${PHX_VIEW_REF}=\"${viewId}\"][${PHX_COMPONENT}=\"${cid}\"]`\n      ).forEach((parent) => {\n        parentCids.add(cid);\n        this.all(parent, `[${PHX_VIEW_REF}=\"${viewId}\"][${PHX_COMPONENT}]`).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => childrenCids.add(childCID));\n      });\n    });\n    childrenCids.forEach((childCid) => parentCids.delete(childCid));\n    return parentCids;\n  },\n  private(el, key) {\n    return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n  },\n  deletePrivate(el, key) {\n    el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n  },\n  putPrivate(el, key, value) {\n    if (!el[PHX_PRIVATE]) {\n      el[PHX_PRIVATE] = {};\n    }\n    el[PHX_PRIVATE][key] = value;\n  },\n  updatePrivate(el, key, defaultVal, updateFunc) {\n    const existing = this.private(el, key);\n    if (existing === void 0) {\n      this.putPrivate(el, key, updateFunc(defaultVal));\n    } else {\n      this.putPrivate(el, key, updateFunc(existing));\n    }\n  },\n  syncPendingAttrs(fromEl, toEl) {\n    if (!fromEl.hasAttribute(PHX_REF_SRC)) {\n      return;\n    }\n    PHX_EVENT_CLASSES.forEach((className) => {\n      fromEl.classList.contains(className) && toEl.classList.add(className);\n    });\n    PHX_PENDING_ATTRS.filter((attr) => fromEl.hasAttribute(attr)).forEach(\n      (attr) => {\n        toEl.setAttribute(attr, fromEl.getAttribute(attr));\n      }\n    );\n  },\n  copyPrivates(target, source) {\n    if (source[PHX_PRIVATE]) {\n      target[PHX_PRIVATE] = source[PHX_PRIVATE];\n    }\n  },\n  putTitle(str) {\n    const titleEl = document.querySelector(\"title\");\n    if (titleEl) {\n      const { prefix, suffix, default: defaultTitle } = titleEl.dataset;\n      const isEmpty2 = typeof str !== \"string\" || str.trim() === \"\";\n      if (isEmpty2 && typeof defaultTitle !== \"string\") {\n        return;\n      }\n      const inner = isEmpty2 ? defaultTitle : str;\n      document.title = `${prefix || \"\"}${inner || \"\"}${suffix || \"\"}`;\n    } else {\n      document.title = str;\n    }\n  },\n  debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {\n    let debounce = el.getAttribute(phxDebounce);\n    let throttle = el.getAttribute(phxThrottle);\n    if (debounce === \"\") {\n      debounce = defaultDebounce;\n    }\n    if (throttle === \"\") {\n      throttle = defaultThrottle;\n    }\n    const value = debounce || throttle;\n    switch (value) {\n      case null:\n        return callback();\n      case \"blur\":\n        this.incCycle(el, \"debounce-blur-cycle\", () => {\n          if (asyncFilter()) {\n            callback();\n          }\n        });\n        if (this.once(el, \"debounce-blur\")) {\n          el.addEventListener(\n            \"blur\",\n            () => this.triggerCycle(el, \"debounce-blur-cycle\")\n          );\n        }\n        return;\n      default:\n        const timeout = parseInt(value);\n        const trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();\n        const currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\n        if (isNaN(timeout)) {\n          return logError(`invalid throttle/debounce value: ${value}`);\n        }\n        if (throttle) {\n          let newKeyDown = false;\n          if (event.type === \"keydown\") {\n            const prevKey = this.private(el, DEBOUNCE_PREV_KEY);\n            this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\n            newKeyDown = prevKey !== event.key;\n          }\n          if (!newKeyDown && this.private(el, THROTTLED)) {\n            return false;\n          } else {\n            callback();\n            const t = setTimeout(() => {\n              if (asyncFilter()) {\n                this.triggerCycle(el, DEBOUNCE_TRIGGER);\n              }\n            }, timeout);\n            this.putPrivate(el, THROTTLED, t);\n          }\n        } else {\n          setTimeout(() => {\n            if (asyncFilter()) {\n              this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);\n            }\n          }, timeout);\n        }\n        const form = el.form;\n        if (form && this.once(form, \"bind-debounce\")) {\n          form.addEventListener(\"submit\", () => {\n            Array.from(new FormData(form).entries(), ([name]) => {\n              const input = form.querySelector(`[name=\"${name}\"]`);\n              this.incCycle(input, DEBOUNCE_TRIGGER);\n              this.deletePrivate(input, THROTTLED);\n            });\n          });\n        }\n        if (this.once(el, \"bind-debounce\")) {\n          el.addEventListener(\"blur\", () => {\n            clearTimeout(this.private(el, THROTTLED));\n            this.triggerCycle(el, DEBOUNCE_TRIGGER);\n          });\n        }\n    }\n  },\n  triggerCycle(el, key, currentCycle) {\n    const [cycle, trigger] = this.private(el, key);\n    if (!currentCycle) {\n      currentCycle = cycle;\n    }\n    if (currentCycle === cycle) {\n      this.incCycle(el, key);\n      trigger();\n    }\n  },\n  once(el, key) {\n    if (this.private(el, key) === true) {\n      return false;\n    }\n    this.putPrivate(el, key, true);\n    return true;\n  },\n  incCycle(el, key, trigger = function() {\n  }) {\n    let [currentCycle] = this.private(el, key) || [0, trigger];\n    currentCycle++;\n    this.putPrivate(el, key, [currentCycle, trigger]);\n    return currentCycle;\n  },\n  // maintains or adds privately used hook information\n  // fromEl and toEl can be the same element in the case of a newly added node\n  // fromEl and toEl can be any HTML node type, so we need to check if it's an element node\n  maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom) {\n    if (fromEl.hasAttribute && fromEl.hasAttribute(\"data-phx-hook\") && !toEl.hasAttribute(\"data-phx-hook\")) {\n      toEl.setAttribute(\"data-phx-hook\", fromEl.getAttribute(\"data-phx-hook\"));\n    }\n    if (toEl.hasAttribute && (toEl.hasAttribute(phxViewportTop) || toEl.hasAttribute(phxViewportBottom))) {\n      toEl.setAttribute(\"data-phx-hook\", \"Phoenix.InfiniteScroll\");\n    }\n  },\n  putCustomElHook(el, hook) {\n    if (el.isConnected) {\n      el.setAttribute(\"data-phx-hook\", \"\");\n    } else {\n      console.error(`\n        hook attached to non-connected DOM element\n        ensure you are calling createHook within your connectedCallback. ${el.outerHTML}\n      `);\n    }\n    this.putPrivate(el, \"custom-el-hook\", hook);\n  },\n  getCustomElHook(el) {\n    return this.private(el, \"custom-el-hook\");\n  },\n  isUsedInput(el) {\n    return el.nodeType === Node.ELEMENT_NODE && (this.private(el, PHX_HAS_FOCUSED) || this.private(el, PHX_HAS_SUBMITTED));\n  },\n  resetForm(form) {\n    Array.from(form.elements).forEach((input) => {\n      this.deletePrivate(input, PHX_HAS_FOCUSED);\n      this.deletePrivate(input, PHX_HAS_SUBMITTED);\n    });\n  },\n  isPhxChild(node) {\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n  },\n  isPhxSticky(node) {\n    return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;\n  },\n  isChildOfAny(el, parents) {\n    return !!parents.find((parent) => parent.contains(el));\n  },\n  firstPhxChild(el) {\n    return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];\n  },\n  isPortalTemplate(el) {\n    return el.tagName === \"TEMPLATE\" && el.hasAttribute(PHX_PORTAL);\n  },\n  closestViewEl(el) {\n    const portalOrViewEl = el.closest(\n      `[${PHX_TELEPORTED_REF}],${PHX_VIEW_SELECTOR}`\n    );\n    if (!portalOrViewEl) {\n      return null;\n    }\n    if (portalOrViewEl.hasAttribute(PHX_TELEPORTED_REF)) {\n      return this.byId(portalOrViewEl.getAttribute(PHX_TELEPORTED_REF));\n    } else if (portalOrViewEl.hasAttribute(PHX_SESSION)) {\n      return portalOrViewEl;\n    }\n    return null;\n  },\n  dispatchEvent(target, name, opts = {}) {\n    let defaultBubble = true;\n    const isUploadTarget = target.nodeName === \"INPUT\" && target.type === \"file\";\n    if (isUploadTarget && name === \"click\") {\n      defaultBubble = false;\n    }\n    const bubbles = opts.bubbles === void 0 ? defaultBubble : !!opts.bubbles;\n    const eventOpts = {\n      bubbles,\n      cancelable: true,\n      detail: opts.detail || {}\n    };\n    const event = name === \"click\" ? new MouseEvent(\"click\", eventOpts) : new CustomEvent(name, eventOpts);\n    target.dispatchEvent(event);\n  },\n  cloneNode(node, html) {\n    if (typeof html === \"undefined\") {\n      return node.cloneNode(true);\n    } else {\n      const cloned = node.cloneNode(false);\n      cloned.innerHTML = html;\n      return cloned;\n    }\n  },\n  // merge attributes from source to target\n  // if an element is ignored, we only merge data attributes\n  // including removing data attributes that are no longer in the source\n  mergeAttrs(target, source, opts = {}) {\n    const exclude = new Set(opts.exclude || []);\n    const isIgnored = opts.isIgnored;\n    const sourceAttrs = source.attributes;\n    for (let i = sourceAttrs.length - 1; i >= 0; i--) {\n      const name = sourceAttrs[i].name;\n      if (!exclude.has(name)) {\n        const sourceValue = source.getAttribute(name);\n        if (target.getAttribute(name) !== sourceValue && (!isIgnored || isIgnored && name.startsWith(\"data-\"))) {\n          target.setAttribute(name, sourceValue);\n        }\n      } else {\n        if (name === \"value\") {\n          const sourceValue = source.value ?? source.getAttribute(name);\n          if (target.value === sourceValue) {\n            target.setAttribute(\"value\", source.getAttribute(name));\n          }\n        }\n      }\n    }\n    const targetAttrs = target.attributes;\n    for (let i = targetAttrs.length - 1; i >= 0; i--) {\n      const name = targetAttrs[i].name;\n      if (isIgnored) {\n        if (name.startsWith(\"data-\") && !source.hasAttribute(name) && !PHX_PENDING_ATTRS.includes(name)) {\n          target.removeAttribute(name);\n        }\n      } else {\n        if (!source.hasAttribute(name)) {\n          target.removeAttribute(name);\n        }\n      }\n    }\n  },\n  mergeFocusedInput(target, source) {\n    if (!(target instanceof HTMLSelectElement)) {\n      DOM.mergeAttrs(target, source, { exclude: [\"value\"] });\n    }\n    if (source.readOnly) {\n      target.setAttribute(\"readonly\", true);\n    } else {\n      target.removeAttribute(\"readonly\");\n    }\n  },\n  hasSelectionRange(el) {\n    return el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\");\n  },\n  restoreFocus(focused, selectionStart, selectionEnd) {\n    if (focused instanceof HTMLSelectElement) {\n      focused.focus();\n    }\n    if (!DOM.isTextualInput(focused)) {\n      return;\n    }\n    const wasFocused = focused.matches(\":focus\");\n    if (!wasFocused) {\n      focused.focus();\n    }\n    if (this.hasSelectionRange(focused)) {\n      focused.setSelectionRange(selectionStart, selectionEnd);\n    }\n  },\n  isFormInput(el) {\n    if (el.localName && customElements.get(el.localName)) {\n      return customElements.get(el.localName)[`formAssociated`];\n    }\n    return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\";\n  },\n  syncAttrsToProps(el) {\n    if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {\n      el.checked = el.getAttribute(\"checked\") !== null;\n    }\n  },\n  isTextualInput(el) {\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n  },\n  isNowTriggerFormExternal(el, phxTriggerExternal) {\n    return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null && document.body.contains(el);\n  },\n  cleanChildNodes(container, phxUpdate) {\n    if (DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\", PHX_STREAM])) {\n      const toRemove = [];\n      container.childNodes.forEach((childNode) => {\n        if (!childNode.id) {\n          const isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === \"\";\n          if (!isEmptyTextNode && childNode.nodeType !== Node.COMMENT_NODE) {\n            logError(\n              `only HTML element tags with an id are allowed inside containers with phx-update.\n\nremoving illegal node: \"${(childNode.outerHTML || childNode.nodeValue).trim()}\"\n\n`\n            );\n          }\n          toRemove.push(childNode);\n        }\n      });\n      toRemove.forEach((childNode) => childNode.remove());\n    }\n  },\n  replaceRootContainer(container, tagName, attrs) {\n    const retainedAttrs = /* @__PURE__ */ new Set([\n      \"id\",\n      PHX_SESSION,\n      PHX_STATIC,\n      PHX_MAIN,\n      PHX_ROOT_ID\n    ]);\n    if (container.tagName.toLowerCase() === tagName.toLowerCase()) {\n      Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));\n      Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));\n      return container;\n    } else {\n      const newContainer = document.createElement(tagName);\n      Object.keys(attrs).forEach(\n        (attr) => newContainer.setAttribute(attr, attrs[attr])\n      );\n      retainedAttrs.forEach(\n        (attr) => newContainer.setAttribute(attr, container.getAttribute(attr))\n      );\n      newContainer.innerHTML = container.innerHTML;\n      container.replaceWith(newContainer);\n      return newContainer;\n    }\n  },\n  getSticky(el, name, defaultVal) {\n    const op = (DOM.private(el, \"sticky\") || []).find(\n      ([existingName]) => name === existingName\n    );\n    if (op) {\n      const [_name, _op, stashedResult] = op;\n      return stashedResult;\n    } else {\n      return typeof defaultVal === \"function\" ? defaultVal() : defaultVal;\n    }\n  },\n  deleteSticky(el, name) {\n    this.updatePrivate(el, \"sticky\", [], (ops) => {\n      return ops.filter(([existingName, _]) => existingName !== name);\n    });\n  },\n  putSticky(el, name, op) {\n    const stashedResult = op(el);\n    this.updatePrivate(el, \"sticky\", [], (ops) => {\n      const existingIndex = ops.findIndex(\n        ([existingName]) => name === existingName\n      );\n      if (existingIndex >= 0) {\n        ops[existingIndex] = [name, op, stashedResult];\n      } else {\n        ops.push([name, op, stashedResult]);\n      }\n      return ops;\n    });\n  },\n  applyStickyOperations(el) {\n    const ops = DOM.private(el, \"sticky\");\n    if (!ops) {\n      return;\n    }\n    ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));\n  },\n  isLocked(el) {\n    return el.hasAttribute && el.hasAttribute(PHX_REF_LOCK);\n  }\n};\nvar dom_default = DOM;\n\n// js/phoenix_live_view/upload_entry.js\nvar UploadEntry = class {\n  static isActive(fileEl, file) {\n    const isNew = file._phxRef === void 0;\n    const activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n    const isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n    return file.size > 0 && (isNew || isActive);\n  }\n  static isPreflighted(fileEl, file) {\n    const preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(\",\");\n    const isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n    return isPreflighted && this.isActive(fileEl, file);\n  }\n  static isPreflightInProgress(file) {\n    return file._preflightInProgress === true;\n  }\n  static markPreflightInProgress(file) {\n    file._preflightInProgress = true;\n  }\n  constructor(fileEl, file, view, autoUpload) {\n    this.ref = LiveUploader.genFileRef(file);\n    this.fileEl = fileEl;\n    this.file = file;\n    this.view = view;\n    this.meta = null;\n    this._isCancelled = false;\n    this._isDone = false;\n    this._progress = 0;\n    this._lastProgressSent = -1;\n    this._onDone = function() {\n    };\n    this._onElUpdated = this.onElUpdated.bind(this);\n    this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    this.autoUpload = autoUpload;\n  }\n  metadata() {\n    return this.meta;\n  }\n  progress(progress) {\n    this._progress = Math.floor(progress);\n    if (this._progress > this._lastProgressSent) {\n      if (this._progress >= 100) {\n        this._progress = 100;\n        this._lastProgressSent = 100;\n        this._isDone = true;\n        this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {\n          LiveUploader.untrackFile(this.fileEl, this.file);\n          this._onDone();\n        });\n      } else {\n        this._lastProgressSent = this._progress;\n        this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\n      }\n    }\n  }\n  isCancelled() {\n    return this._isCancelled;\n  }\n  cancel() {\n    this.file._preflightInProgress = false;\n    this._isCancelled = true;\n    this._isDone = true;\n    this._onDone();\n  }\n  isDone() {\n    return this._isDone;\n  }\n  error(reason = \"failed\") {\n    this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });\n    if (!this.isAutoUpload()) {\n      LiveUploader.clearFiles(this.fileEl);\n    }\n  }\n  isAutoUpload() {\n    return this.autoUpload;\n  }\n  //private\n  onDone(callback) {\n    this._onDone = () => {\n      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n      callback();\n    };\n  }\n  onElUpdated() {\n    const activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n    if (activeRefs.indexOf(this.ref) === -1) {\n      LiveUploader.untrackFile(this.fileEl, this.file);\n      this.cancel();\n    }\n  }\n  toPreflightPayload() {\n    return {\n      last_modified: this.file.lastModified,\n      name: this.file.name,\n      relative_path: this.file.webkitRelativePath,\n      size: this.file.size,\n      type: this.file.type,\n      ref: this.ref,\n      meta: typeof this.file.meta === \"function\" ? this.file.meta() : void 0\n    };\n  }\n  uploader(uploaders) {\n    if (this.meta.uploader) {\n      const callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);\n      return { name: this.meta.uploader, callback };\n    } else {\n      return { name: \"channel\", callback: channelUploader };\n    }\n  }\n  zipPostFlight(resp) {\n    this.meta = resp.entries[this.ref];\n    if (!this.meta) {\n      logError(`no preflight upload response returned with ref ${this.ref}`, {\n        input: this.fileEl,\n        response: resp\n      });\n    }\n  }\n};\n\n// js/phoenix_live_view/live_uploader.js\nvar liveUploaderFileRef = 0;\nvar LiveUploader = class _LiveUploader {\n  static genFileRef(file) {\n    const ref = file._phxRef;\n    if (ref !== void 0) {\n      return ref;\n    } else {\n      file._phxRef = (liveUploaderFileRef++).toString();\n      return file._phxRef;\n    }\n  }\n  static getEntryDataURL(inputEl, ref, callback) {\n    const file = this.activeFiles(inputEl).find(\n      (file2) => this.genFileRef(file2) === ref\n    );\n    callback(URL.createObjectURL(file));\n  }\n  static hasUploadsInProgress(formEl) {\n    let active = 0;\n    dom_default.findUploadInputs(formEl).forEach((input) => {\n      if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {\n        active++;\n      }\n    });\n    return active > 0;\n  }\n  static serializeUploads(inputEl) {\n    const files = this.activeFiles(inputEl);\n    const fileData = {};\n    files.forEach((file) => {\n      const entry = { path: inputEl.name };\n      const uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);\n      fileData[uploadRef] = fileData[uploadRef] || [];\n      entry.ref = this.genFileRef(file);\n      entry.last_modified = file.lastModified;\n      entry.name = file.name || entry.ref;\n      entry.relative_path = file.webkitRelativePath;\n      entry.type = file.type;\n      entry.size = file.size;\n      if (typeof file.meta === \"function\") {\n        entry.meta = file.meta();\n      }\n      fileData[uploadRef].push(entry);\n    });\n    return fileData;\n  }\n  static clearFiles(inputEl) {\n    inputEl.value = null;\n    inputEl.removeAttribute(PHX_UPLOAD_REF);\n    dom_default.putPrivate(inputEl, \"files\", []);\n  }\n  static untrackFile(inputEl, file) {\n    dom_default.putPrivate(\n      inputEl,\n      \"files\",\n      dom_default.private(inputEl, \"files\").filter((f) => !Object.is(f, file))\n    );\n  }\n  /**\n   * @param {HTMLInputElement} inputEl\n   * @param {Array<File|Blob>} files\n   * @param {DataTransfer} [dataTransfer]\n   */\n  static trackFiles(inputEl, files, dataTransfer) {\n    if (inputEl.getAttribute(\"multiple\") !== null) {\n      const newFiles = files.filter(\n        (file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file))\n      );\n      dom_default.updatePrivate(\n        inputEl,\n        \"files\",\n        [],\n        (existing) => existing.concat(newFiles)\n      );\n      inputEl.value = null;\n    } else {\n      if (dataTransfer && dataTransfer.files.length > 0) {\n        inputEl.files = dataTransfer.files;\n      }\n      dom_default.putPrivate(inputEl, \"files\", files);\n    }\n  }\n  static activeFileInputs(formEl) {\n    const fileInputs = dom_default.findUploadInputs(formEl);\n    return Array.from(fileInputs).filter(\n      (el) => el.files && this.activeFiles(el).length > 0\n    );\n  }\n  static activeFiles(input) {\n    return (dom_default.private(input, \"files\") || []).filter(\n      (f) => UploadEntry.isActive(input, f)\n    );\n  }\n  static inputsAwaitingPreflight(formEl) {\n    const fileInputs = dom_default.findUploadInputs(formEl);\n    return Array.from(fileInputs).filter(\n      (input) => this.filesAwaitingPreflight(input).length > 0\n    );\n  }\n  static filesAwaitingPreflight(input) {\n    return this.activeFiles(input).filter(\n      (f) => !UploadEntry.isPreflighted(input, f) && !UploadEntry.isPreflightInProgress(f)\n    );\n  }\n  static markPreflightInProgress(entries) {\n    entries.forEach((entry) => UploadEntry.markPreflightInProgress(entry.file));\n  }\n  constructor(inputEl, view, onComplete) {\n    this.autoUpload = dom_default.isAutoUpload(inputEl);\n    this.view = view;\n    this.onComplete = onComplete;\n    this._entries = Array.from(\n      _LiveUploader.filesAwaitingPreflight(inputEl) || []\n    ).map((file) => new UploadEntry(inputEl, file, view, this.autoUpload));\n    _LiveUploader.markPreflightInProgress(this._entries);\n    this.numEntriesInProgress = this._entries.length;\n  }\n  isAutoUpload() {\n    return this.autoUpload;\n  }\n  entries() {\n    return this._entries;\n  }\n  initAdapterUpload(resp, onError, liveSocket) {\n    this._entries = this._entries.map((entry) => {\n      if (entry.isCancelled()) {\n        this.numEntriesInProgress--;\n        if (this.numEntriesInProgress === 0) {\n          this.onComplete();\n        }\n      } else {\n        entry.zipPostFlight(resp);\n        entry.onDone(() => {\n          this.numEntriesInProgress--;\n          if (this.numEntriesInProgress === 0) {\n            this.onComplete();\n          }\n        });\n      }\n      return entry;\n    });\n    const groupedEntries = this._entries.reduce((acc, entry) => {\n      if (!entry.meta) {\n        return acc;\n      }\n      const { name, callback } = entry.uploader(liveSocket.uploaders);\n      acc[name] = acc[name] || { callback, entries: [] };\n      acc[name].entries.push(entry);\n      return acc;\n    }, {});\n    for (const name in groupedEntries) {\n      const { callback, entries } = groupedEntries[name];\n      callback(entries, onError, resp, liveSocket);\n    }\n  }\n};\n\n// js/phoenix_live_view/aria.js\nvar ARIA = {\n  anyOf(instance, classes) {\n    return classes.find((name) => instance instanceof name);\n  },\n  isFocusable(el, interactiveOnly) {\n    return el instanceof HTMLAnchorElement && el.rel !== \"ignore\" || el instanceof HTMLAreaElement && el.href !== void 0 || !el.disabled && this.anyOf(el, [\n      HTMLInputElement,\n      HTMLSelectElement,\n      HTMLTextAreaElement,\n      HTMLButtonElement\n    ]) || el instanceof HTMLIFrameElement || el.tabIndex >= 0 && el.getAttribute(\"aria-hidden\") !== \"true\" || !interactiveOnly && el.getAttribute(\"tabindex\") !== null && el.getAttribute(\"aria-hidden\") !== \"true\";\n  },\n  attemptFocus(el, interactiveOnly) {\n    if (this.isFocusable(el, interactiveOnly)) {\n      try {\n        el.focus();\n      } catch {\n      }\n    }\n    return !!document.activeElement && document.activeElement.isSameNode(el);\n  },\n  focusFirstInteractive(el) {\n    let child = el.firstElementChild;\n    while (child) {\n      if (this.attemptFocus(child, true) || this.focusFirstInteractive(child)) {\n        return true;\n      }\n      child = child.nextElementSibling;\n    }\n  },\n  focusFirst(el) {\n    let child = el.firstElementChild;\n    while (child) {\n      if (this.attemptFocus(child) || this.focusFirst(child)) {\n        return true;\n      }\n      child = child.nextElementSibling;\n    }\n  },\n  focusLast(el) {\n    let child = el.lastElementChild;\n    while (child) {\n      if (this.attemptFocus(child) || this.focusLast(child)) {\n        return true;\n      }\n      child = child.previousElementSibling;\n    }\n  }\n};\nvar aria_default = ARIA;\n\n// js/phoenix_live_view/hooks.js\nvar Hooks = {\n  LiveFileUpload: {\n    activeRefs() {\n      return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);\n    },\n    preflightedRefs() {\n      return this.el.getAttribute(PHX_PREFLIGHTED_REFS);\n    },\n    mounted() {\n      this.preflightedWas = this.preflightedRefs();\n    },\n    updated() {\n      const newPreflights = this.preflightedRefs();\n      if (this.preflightedWas !== newPreflights) {\n        this.preflightedWas = newPreflights;\n        if (newPreflights === \"\") {\n          this.__view().cancelSubmit(this.el.form);\n        }\n      }\n      if (this.activeRefs() === \"\") {\n        this.el.value = null;\n      }\n      this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));\n    }\n  },\n  LiveImgPreview: {\n    mounted() {\n      this.ref = this.el.getAttribute(\"data-phx-entry-ref\");\n      this.inputEl = document.getElementById(\n        this.el.getAttribute(PHX_UPLOAD_REF)\n      );\n      LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {\n        this.url = url;\n        this.el.src = url;\n      });\n    },\n    destroyed() {\n      URL.revokeObjectURL(this.url);\n    }\n  },\n  FocusWrap: {\n    mounted() {\n      this.focusStart = this.el.firstElementChild;\n      this.focusEnd = this.el.lastElementChild;\n      this.focusStart.addEventListener(\"focus\", (e) => {\n        if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {\n          const nextFocus = e.target.nextElementSibling;\n          aria_default.attemptFocus(nextFocus) || aria_default.focusFirst(nextFocus);\n        } else {\n          aria_default.focusLast(this.el);\n        }\n      });\n      this.focusEnd.addEventListener(\"focus\", (e) => {\n        if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {\n          const nextFocus = e.target.previousElementSibling;\n          aria_default.attemptFocus(nextFocus) || aria_default.focusLast(nextFocus);\n        } else {\n          aria_default.focusFirst(this.el);\n        }\n      });\n      if (!this.el.contains(document.activeElement)) {\n        this.el.addEventListener(\"phx:show-end\", () => this.el.focus());\n        if (window.getComputedStyle(this.el).display !== \"none\") {\n          aria_default.focusFirst(this.el);\n        }\n      }\n    }\n  }\n};\nvar findScrollContainer = (el) => {\n  if ([\"HTML\", \"BODY\"].indexOf(el.nodeName.toUpperCase()) >= 0)\n    return null;\n  if ([\"scroll\", \"auto\"].indexOf(getComputedStyle(el).overflowY) >= 0)\n    return el;\n  return findScrollContainer(el.parentElement);\n};\nvar scrollTop = (scrollContainer) => {\n  if (scrollContainer) {\n    return scrollContainer.scrollTop;\n  } else {\n    return document.documentElement.scrollTop || document.body.scrollTop;\n  }\n};\nvar bottom = (scrollContainer) => {\n  if (scrollContainer) {\n    return scrollContainer.getBoundingClientRect().bottom;\n  } else {\n    return window.innerHeight || document.documentElement.clientHeight;\n  }\n};\nvar top = (scrollContainer) => {\n  if (scrollContainer) {\n    return scrollContainer.getBoundingClientRect().top;\n  } else {\n    return 0;\n  }\n};\nvar isAtViewportTop = (el, scrollContainer) => {\n  const rect = el.getBoundingClientRect();\n  return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);\n};\nvar isAtViewportBottom = (el, scrollContainer) => {\n  const rect = el.getBoundingClientRect();\n  return Math.ceil(rect.bottom) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.bottom) <= bottom(scrollContainer);\n};\nvar isWithinViewport = (el, scrollContainer) => {\n  const rect = el.getBoundingClientRect();\n  return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);\n};\nHooks.InfiniteScroll = {\n  mounted() {\n    this.scrollContainer = findScrollContainer(this.el);\n    let scrollBefore = scrollTop(this.scrollContainer);\n    let topOverran = false;\n    const throttleInterval = 500;\n    let pendingOp = null;\n    const onTopOverrun = this.throttle(\n      throttleInterval,\n      (topEvent, firstChild) => {\n        pendingOp = () => true;\n        this.liveSocket.js().push(this.el, topEvent, {\n          value: { id: firstChild.id, _overran: true },\n          callback: () => {\n            pendingOp = null;\n          }\n        });\n      }\n    );\n    const onFirstChildAtTop = this.throttle(\n      throttleInterval,\n      (topEvent, firstChild) => {\n        pendingOp = () => firstChild.scrollIntoView({ block: \"start\" });\n        this.liveSocket.js().push(this.el, topEvent, {\n          value: { id: firstChild.id },\n          callback: () => {\n            pendingOp = null;\n            window.requestAnimationFrame(() => {\n              if (!isWithinViewport(firstChild, this.scrollContainer)) {\n                firstChild.scrollIntoView({ block: \"start\" });\n              }\n            });\n          }\n        });\n      }\n    );\n    const onLastChildAtBottom = this.throttle(\n      throttleInterval,\n      (bottomEvent, lastChild) => {\n        pendingOp = () => lastChild.scrollIntoView({ block: \"end\" });\n        this.liveSocket.js().push(this.el, bottomEvent, {\n          value: { id: lastChild.id },\n          callback: () => {\n            pendingOp = null;\n            window.requestAnimationFrame(() => {\n              if (!isWithinViewport(lastChild, this.scrollContainer)) {\n                lastChild.scrollIntoView({ block: \"end\" });\n              }\n            });\n          }\n        });\n      }\n    );\n    this.onScroll = (_e) => {\n      const scrollNow = scrollTop(this.scrollContainer);\n      if (pendingOp) {\n        scrollBefore = scrollNow;\n        return pendingOp();\n      }\n      const rect = this.el.getBoundingClientRect();\n      const topEvent = this.el.getAttribute(\n        this.liveSocket.binding(\"viewport-top\")\n      );\n      const bottomEvent = this.el.getAttribute(\n        this.liveSocket.binding(\"viewport-bottom\")\n      );\n      const lastChild = this.el.lastElementChild;\n      const firstChild = this.el.firstElementChild;\n      const isScrollingUp = scrollNow < scrollBefore;\n      const isScrollingDown = scrollNow > scrollBefore;\n      if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {\n        topOverran = true;\n        onTopOverrun(topEvent, firstChild);\n      } else if (isScrollingDown && topOverran && rect.top <= 0) {\n        topOverran = false;\n      }\n      if (topEvent && isScrollingUp && isAtViewportTop(firstChild, this.scrollContainer)) {\n        onFirstChildAtTop(topEvent, firstChild);\n      } else if (bottomEvent && isScrollingDown && isAtViewportBottom(lastChild, this.scrollContainer)) {\n        onLastChildAtBottom(bottomEvent, lastChild);\n      }\n      scrollBefore = scrollNow;\n    };\n    if (this.scrollContainer) {\n      this.scrollContainer.addEventListener(\"scroll\", this.onScroll);\n    } else {\n      window.addEventListener(\"scroll\", this.onScroll);\n    }\n  },\n  destroyed() {\n    if (this.scrollContainer) {\n      this.scrollContainer.removeEventListener(\"scroll\", this.onScroll);\n    } else {\n      window.removeEventListener(\"scroll\", this.onScroll);\n    }\n  },\n  throttle(interval, callback) {\n    let lastCallAt = 0;\n    let timer;\n    return (...args) => {\n      const now = Date.now();\n      const remainingTime = interval - (now - lastCallAt);\n      if (remainingTime <= 0 || remainingTime > interval) {\n        if (timer) {\n          clearTimeout(timer);\n          timer = null;\n        }\n        lastCallAt = now;\n        callback(...args);\n      } else if (!timer) {\n        timer = setTimeout(() => {\n          lastCallAt = Date.now();\n          timer = null;\n          callback(...args);\n        }, remainingTime);\n      }\n    };\n  }\n};\nvar hooks_default = Hooks;\n\n// js/phoenix_live_view/element_ref.js\nvar ElementRef = class {\n  static onUnlock(el, callback) {\n    if (!dom_default.isLocked(el) && !el.closest(`[${PHX_REF_LOCK}]`)) {\n      return callback();\n    }\n    const closestLock = el.closest(`[${PHX_REF_LOCK}]`);\n    const ref = closestLock.closest(`[${PHX_REF_LOCK}]`).getAttribute(PHX_REF_LOCK);\n    closestLock.addEventListener(\n      `phx:undo-lock:${ref}`,\n      () => {\n        callback();\n      },\n      { once: true }\n    );\n  }\n  constructor(el) {\n    this.el = el;\n    this.loadingRef = el.hasAttribute(PHX_REF_LOADING) ? parseInt(el.getAttribute(PHX_REF_LOADING), 10) : null;\n    this.lockRef = el.hasAttribute(PHX_REF_LOCK) ? parseInt(el.getAttribute(PHX_REF_LOCK), 10) : null;\n  }\n  // public\n  maybeUndo(ref, phxEvent, eachCloneCallback) {\n    if (!this.isWithin(ref)) {\n      dom_default.updatePrivate(this.el, PHX_PENDING_REFS, [], (pendingRefs) => {\n        pendingRefs.push(ref);\n        return pendingRefs;\n      });\n      return;\n    }\n    this.undoLocks(ref, phxEvent, eachCloneCallback);\n    this.undoLoading(ref, phxEvent);\n    dom_default.updatePrivate(this.el, PHX_PENDING_REFS, [], (pendingRefs) => {\n      return pendingRefs.filter((pendingRef) => {\n        let opts = {\n          detail: { ref: pendingRef, event: phxEvent },\n          bubbles: true,\n          cancelable: false\n        };\n        if (this.loadingRef && this.loadingRef > pendingRef) {\n          this.el.dispatchEvent(\n            new CustomEvent(`phx:undo-loading:${pendingRef}`, opts)\n          );\n        }\n        if (this.lockRef && this.lockRef > pendingRef) {\n          this.el.dispatchEvent(\n            new CustomEvent(`phx:undo-lock:${pendingRef}`, opts)\n          );\n        }\n        return pendingRef > ref;\n      });\n    });\n    if (this.isFullyResolvedBy(ref)) {\n      this.el.removeAttribute(PHX_REF_SRC);\n    }\n  }\n  // private\n  isWithin(ref) {\n    return !(this.loadingRef !== null && this.loadingRef > ref && this.lockRef !== null && this.lockRef > ref);\n  }\n  // Check for cloned PHX_REF_LOCK element that has been morphed behind\n  // the scenes while this element was locked in the DOM.\n  // When we apply the cloned tree to the active DOM element, we must\n  //\n  //   1. execute pending mounted hooks for nodes now in the DOM\n  //   2. undo any ref inside the cloned tree that has since been ack'd\n  undoLocks(ref, phxEvent, eachCloneCallback) {\n    if (!this.isLockUndoneBy(ref)) {\n      return;\n    }\n    const clonedTree = dom_default.private(this.el, PHX_REF_LOCK);\n    if (clonedTree) {\n      eachCloneCallback(clonedTree);\n      dom_default.deletePrivate(this.el, PHX_REF_LOCK);\n    }\n    this.el.removeAttribute(PHX_REF_LOCK);\n    const opts = {\n      detail: { ref, event: phxEvent },\n      bubbles: true,\n      cancelable: false\n    };\n    this.el.dispatchEvent(\n      new CustomEvent(`phx:undo-lock:${this.lockRef}`, opts)\n    );\n  }\n  undoLoading(ref, phxEvent) {\n    if (!this.isLoadingUndoneBy(ref)) {\n      if (this.canUndoLoading(ref) && this.el.classList.contains(\"phx-submit-loading\")) {\n        this.el.classList.remove(\"phx-change-loading\");\n      }\n      return;\n    }\n    if (this.canUndoLoading(ref)) {\n      this.el.removeAttribute(PHX_REF_LOADING);\n      const disabledVal = this.el.getAttribute(PHX_DISABLED);\n      const readOnlyVal = this.el.getAttribute(PHX_READONLY);\n      if (readOnlyVal !== null) {\n        this.el.readOnly = readOnlyVal === \"true\" ? true : false;\n        this.el.removeAttribute(PHX_READONLY);\n      }\n      if (disabledVal !== null) {\n        this.el.disabled = disabledVal === \"true\" ? true : false;\n        this.el.removeAttribute(PHX_DISABLED);\n      }\n      const disableRestore = this.el.getAttribute(PHX_DISABLE_WITH_RESTORE);\n      if (disableRestore !== null) {\n        this.el.innerText = disableRestore;\n        this.el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\n      }\n      const opts = {\n        detail: { ref, event: phxEvent },\n        bubbles: true,\n        cancelable: false\n      };\n      this.el.dispatchEvent(\n        new CustomEvent(`phx:undo-loading:${this.loadingRef}`, opts)\n      );\n    }\n    PHX_EVENT_CLASSES.forEach((name) => {\n      if (name !== \"phx-submit-loading\" || this.canUndoLoading(ref)) {\n        dom_default.removeClass(this.el, name);\n      }\n    });\n  }\n  isLoadingUndoneBy(ref) {\n    return this.loadingRef === null ? false : this.loadingRef <= ref;\n  }\n  isLockUndoneBy(ref) {\n    return this.lockRef === null ? false : this.lockRef <= ref;\n  }\n  isFullyResolvedBy(ref) {\n    return (this.loadingRef === null || this.loadingRef <= ref) && (this.lockRef === null || this.lockRef <= ref);\n  }\n  // only remove the phx-submit-loading class if we are not locked\n  canUndoLoading(ref) {\n    return this.lockRef === null || this.lockRef <= ref;\n  }\n};\n\n// js/phoenix_live_view/dom_post_morph_restorer.js\nvar DOMPostMorphRestorer = class {\n  constructor(containerBefore, containerAfter, updateType) {\n    const idsBefore = /* @__PURE__ */ new Set();\n    const idsAfter = new Set(\n      [...containerAfter.children].map((child) => child.id)\n    );\n    const elementsToModify = [];\n    Array.from(containerBefore.children).forEach((child) => {\n      if (child.id) {\n        idsBefore.add(child.id);\n        if (idsAfter.has(child.id)) {\n          const previousElementId = child.previousElementSibling && child.previousElementSibling.id;\n          elementsToModify.push({\n            elementId: child.id,\n            previousElementId\n          });\n        }\n      }\n    });\n    this.containerId = containerAfter.id;\n    this.updateType = updateType;\n    this.elementsToModify = elementsToModify;\n    this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));\n  }\n  // We do the following to optimize append/prepend operations:\n  //   1) Track ids of modified elements & of new elements\n  //   2) All the modified elements are put back in the correct position in the DOM tree\n  //      by storing the id of their previous sibling\n  //   3) New elements are going to be put in the right place by morphdom during append.\n  //      For prepend, we move them to the first position in the container\n  perform() {\n    const container = dom_default.byId(this.containerId);\n    if (!container) {\n      return;\n    }\n    this.elementsToModify.forEach((elementToModify) => {\n      if (elementToModify.previousElementId) {\n        maybe(\n          document.getElementById(elementToModify.previousElementId),\n          (previousElem) => {\n            maybe(\n              document.getElementById(elementToModify.elementId),\n              (elem) => {\n                const isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;\n                if (!isInRightPlace) {\n                  previousElem.insertAdjacentElement(\"afterend\", elem);\n                }\n              }\n            );\n          }\n        );\n      } else {\n        maybe(document.getElementById(elementToModify.elementId), (elem) => {\n          const isInRightPlace = elem.previousElementSibling == null;\n          if (!isInRightPlace) {\n            container.insertAdjacentElement(\"afterbegin\", elem);\n          }\n        });\n      }\n    });\n    if (this.updateType == \"prepend\") {\n      this.elementIdsToAdd.reverse().forEach((elemId) => {\n        maybe(\n          document.getElementById(elemId),\n          (elem) => container.insertAdjacentElement(\"afterbegin\", elem)\n        );\n      });\n    }\n  }\n};\n\n// ../node_modules/morphdom/dist/morphdom-esm.js\nvar DOCUMENT_FRAGMENT_NODE = 11;\nfunction morphAttrs(fromNode, toNode) {\n  var toNodeAttrs = toNode.attributes;\n  var attr;\n  var attrName;\n  var attrNamespaceURI;\n  var attrValue;\n  var fromValue;\n  if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    return;\n  }\n  for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n    attr = toNodeAttrs[i];\n    attrName = attr.name;\n    attrNamespaceURI = attr.namespaceURI;\n    attrValue = attr.value;\n    if (attrNamespaceURI) {\n      attrName = attr.localName || attrName;\n      fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n      if (fromValue !== attrValue) {\n        if (attr.prefix === \"xmlns\") {\n          attrName = attr.name;\n        }\n        fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n      }\n    } else {\n      fromValue = fromNode.getAttribute(attrName);\n      if (fromValue !== attrValue) {\n        fromNode.setAttribute(attrName, attrValue);\n      }\n    }\n  }\n  var fromNodeAttrs = fromNode.attributes;\n  for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n    attr = fromNodeAttrs[d];\n    attrName = attr.name;\n    attrNamespaceURI = attr.namespaceURI;\n    if (attrNamespaceURI) {\n      attrName = attr.localName || attrName;\n      if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n        fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n      }\n    } else {\n      if (!toNode.hasAttribute(attrName)) {\n        fromNode.removeAttribute(attrName);\n      }\n    }\n  }\n}\nvar range;\nvar NS_XHTML = \"http://www.w3.org/1999/xhtml\";\nvar doc = typeof document === \"undefined\" ? void 0 : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && \"content\" in doc.createElement(\"template\");\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && \"createContextualFragment\" in doc.createRange();\nfunction createFragmentFromTemplate(str) {\n  var template = doc.createElement(\"template\");\n  template.innerHTML = str;\n  return template.content.childNodes[0];\n}\nfunction createFragmentFromRange(str) {\n  if (!range) {\n    range = doc.createRange();\n    range.selectNode(doc.body);\n  }\n  var fragment = range.createContextualFragment(str);\n  return fragment.childNodes[0];\n}\nfunction createFragmentFromWrap(str) {\n  var fragment = doc.createElement(\"body\");\n  fragment.innerHTML = str;\n  return fragment.childNodes[0];\n}\nfunction toElement(str) {\n  str = str.trim();\n  if (HAS_TEMPLATE_SUPPORT) {\n    return createFragmentFromTemplate(str);\n  } else if (HAS_RANGE_SUPPORT) {\n    return createFragmentFromRange(str);\n  }\n  return createFragmentFromWrap(str);\n}\nfunction compareNodeNames(fromEl, toEl) {\n  var fromNodeName = fromEl.nodeName;\n  var toNodeName = toEl.nodeName;\n  var fromCodeStart, toCodeStart;\n  if (fromNodeName === toNodeName) {\n    return true;\n  }\n  fromCodeStart = fromNodeName.charCodeAt(0);\n  toCodeStart = toNodeName.charCodeAt(0);\n  if (fromCodeStart <= 90 && toCodeStart >= 97) {\n    return fromNodeName === toNodeName.toUpperCase();\n  } else if (toCodeStart <= 90 && fromCodeStart >= 97) {\n    return toNodeName === fromNodeName.toUpperCase();\n  } else {\n    return false;\n  }\n}\nfunction createElementNS(name, namespaceURI) {\n  return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);\n}\nfunction moveChildren(fromEl, toEl) {\n  var curChild = fromEl.firstChild;\n  while (curChild) {\n    var nextChild = curChild.nextSibling;\n    toEl.appendChild(curChild);\n    curChild = nextChild;\n  }\n  return toEl;\n}\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n  if (fromEl[name] !== toEl[name]) {\n    fromEl[name] = toEl[name];\n    if (fromEl[name]) {\n      fromEl.setAttribute(name, \"\");\n    } else {\n      fromEl.removeAttribute(name);\n    }\n  }\n}\nvar specialElHandlers = {\n  OPTION: function(fromEl, toEl) {\n    var parentNode = fromEl.parentNode;\n    if (parentNode) {\n      var parentName = parentNode.nodeName.toUpperCase();\n      if (parentName === \"OPTGROUP\") {\n        parentNode = parentNode.parentNode;\n        parentName = parentNode && parentNode.nodeName.toUpperCase();\n      }\n      if (parentName === \"SELECT\" && !parentNode.hasAttribute(\"multiple\")) {\n        if (fromEl.hasAttribute(\"selected\") && !toEl.selected) {\n          fromEl.setAttribute(\"selected\", \"selected\");\n          fromEl.removeAttribute(\"selected\");\n        }\n        parentNode.selectedIndex = -1;\n      }\n    }\n    syncBooleanAttrProp(fromEl, toEl, \"selected\");\n  },\n  /**\n   * The \"value\" attribute is special for the <input> element since it sets\n   * the initial value. Changing the \"value\" attribute without changing the\n   * \"value\" property will have no effect since it is only used to the set the\n   * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n   */\n  INPUT: function(fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"checked\");\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n    if (fromEl.value !== toEl.value) {\n      fromEl.value = toEl.value;\n    }\n    if (!toEl.hasAttribute(\"value\")) {\n      fromEl.removeAttribute(\"value\");\n    }\n  },\n  TEXTAREA: function(fromEl, toEl) {\n    var newValue = toEl.value;\n    if (fromEl.value !== newValue) {\n      fromEl.value = newValue;\n    }\n    var firstChild = fromEl.firstChild;\n    if (firstChild) {\n      var oldValue = firstChild.nodeValue;\n      if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {\n        return;\n      }\n      firstChild.nodeValue = newValue;\n    }\n  },\n  SELECT: function(fromEl, toEl) {\n    if (!toEl.hasAttribute(\"multiple\")) {\n      var selectedIndex = -1;\n      var i = 0;\n      var curChild = fromEl.firstChild;\n      var optgroup;\n      var nodeName;\n      while (curChild) {\n        nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n        if (nodeName === \"OPTGROUP\") {\n          optgroup = curChild;\n          curChild = optgroup.firstChild;\n          if (!curChild) {\n            curChild = optgroup.nextSibling;\n            optgroup = null;\n          }\n        } else {\n          if (nodeName === \"OPTION\") {\n            if (curChild.hasAttribute(\"selected\")) {\n              selectedIndex = i;\n              break;\n            }\n            i++;\n          }\n          curChild = curChild.nextSibling;\n          if (!curChild && optgroup) {\n            curChild = optgroup.nextSibling;\n            optgroup = null;\n          }\n        }\n      }\n      fromEl.selectedIndex = selectedIndex;\n    }\n  }\n};\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nfunction noop() {\n}\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return node.getAttribute && node.getAttribute(\"id\") || node.id;\n  }\n}\nfunction morphdomFactory(morphAttrs2) {\n  return function morphdom2(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n    if (typeof toNode === \"string\") {\n      if (fromNode.nodeName === \"#document\" || fromNode.nodeName === \"HTML\" || fromNode.nodeName === \"BODY\") {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement(\"html\");\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function(parent, child) {\n      return parent.appendChild(child);\n    };\n    var childrenOnly = options.childrenOnly === true;\n    var fromNodesLookup = /* @__PURE__ */ Object.create(null);\n    var keyedRemovalList = [];\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = void 0;\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            addKeyedRemoval(key);\n          } else {\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n          indexTree(curChild);\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n    indexTree(fromNode);\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          handleNodeAdded(curChild);\n        }\n        curChild = nextSibling;\n      }\n    }\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if (curFromNodeKey = getNodeKey(curFromNodeChild)) {\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          removeNode(\n            curFromNodeChild,\n            fromEl,\n            true\n            /* skip keyed nodes */\n          );\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n    function morphEl(fromEl, toEl, childrenOnly2) {\n      var toElKey = getNodeKey(toEl);\n      if (toElKey) {\n        delete fromNodesLookup[toElKey];\n      }\n      if (!childrenOnly2) {\n        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);\n        if (beforeUpdateResult === false) {\n          return;\n        } else if (beforeUpdateResult instanceof HTMLElement) {\n          fromEl = beforeUpdateResult;\n          indexTree(fromEl);\n        }\n        morphAttrs2(fromEl, toEl);\n        onElUpdated(fromEl);\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n      if (fromEl.nodeName !== \"TEXTAREA\") {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n      outer:\n        while (curToNodeChild) {\n          toNextSibling = curToNodeChild.nextSibling;\n          curToNodeKey = getNodeKey(curToNodeChild);\n          while (!skipFrom && curFromNodeChild) {\n            fromNextSibling = curFromNodeChild.nextSibling;\n            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n            curFromNodeKey = getNodeKey(curFromNodeChild);\n            var curFromNodeType = curFromNodeChild.nodeType;\n            var isCompatible = void 0;\n            if (curFromNodeType === curToNodeChild.nodeType) {\n              if (curFromNodeType === ELEMENT_NODE) {\n                if (curToNodeKey) {\n                  if (curToNodeKey !== curFromNodeKey) {\n                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {\n                      if (fromNextSibling === matchingFromEl) {\n                        isCompatible = false;\n                      } else {\n                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n                        if (curFromNodeKey) {\n                          addKeyedRemoval(curFromNodeKey);\n                        } else {\n                          removeNode(\n                            curFromNodeChild,\n                            fromEl,\n                            true\n                            /* skip keyed nodes */\n                          );\n                        }\n                        curFromNodeChild = matchingFromEl;\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n                      }\n                    } else {\n                      isCompatible = false;\n                    }\n                  }\n                } else if (curFromNodeKey) {\n                  isCompatible = false;\n                }\n                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                if (isCompatible) {\n                  morphEl(curFromNodeChild, curToNodeChild);\n                }\n              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                isCompatible = true;\n                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                }\n              }\n            }\n            if (isCompatible) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n            if (curFromNodeKey) {\n              addKeyedRemoval(curFromNodeKey);\n            } else {\n              removeNode(\n                curFromNodeChild,\n                fromEl,\n                true\n                /* skip keyed nodes */\n              );\n            }\n            curFromNodeChild = fromNextSibling;\n          }\n          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n            if (!skipFrom) {\n              addChild(fromEl, matchingFromEl);\n            }\n            morphEl(matchingFromEl, curToNodeChild);\n          } else {\n            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n            if (onBeforeNodeAddedResult !== false) {\n              if (onBeforeNodeAddedResult) {\n                curToNodeChild = onBeforeNodeAddedResult;\n              }\n              if (curToNodeChild.actualize) {\n                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n              }\n              addChild(fromEl, curToNodeChild);\n              handleNodeAdded(curToNodeChild);\n            }\n          }\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n        }\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    }\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n    if (!childrenOnly) {\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n          return morphedNode;\n        } else {\n          morphedNode = toNode;\n        }\n      }\n    }\n    if (morphedNode === toNode) {\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n      morphEl(morphedNode, toNode, childrenOnly);\n      if (keyedRemovalList) {\n        for (var i = 0, len = keyedRemovalList.length; i < len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n    return morphedNode;\n  };\n}\nvar morphdom = morphdomFactory(morphAttrs);\nvar morphdom_esm_default = morphdom;\n\n// js/phoenix_live_view/dom_patch.js\nvar DOMPatch = class {\n  constructor(view, container, id, html, streams, targetCID, opts = {}) {\n    this.view = view;\n    this.liveSocket = view.liveSocket;\n    this.container = container;\n    this.id = id;\n    this.rootID = view.root.id;\n    this.html = html;\n    this.streams = streams;\n    this.streamInserts = {};\n    this.streamComponentRestore = {};\n    this.targetCID = targetCID;\n    this.cidPatch = isCid(this.targetCID);\n    this.pendingRemoves = [];\n    this.phxRemove = this.liveSocket.binding(\"remove\");\n    this.targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;\n    this.callbacks = {\n      beforeadded: [],\n      beforeupdated: [],\n      beforephxChildAdded: [],\n      afteradded: [],\n      afterupdated: [],\n      afterdiscarded: [],\n      afterphxChildAdded: [],\n      aftertransitionsDiscarded: []\n    };\n    this.withChildren = opts.withChildren || opts.undoRef || false;\n    this.undoRef = opts.undoRef;\n  }\n  before(kind, callback) {\n    this.callbacks[`before${kind}`].push(callback);\n  }\n  after(kind, callback) {\n    this.callbacks[`after${kind}`].push(callback);\n  }\n  trackBefore(kind, ...args) {\n    this.callbacks[`before${kind}`].forEach((callback) => callback(...args));\n  }\n  trackAfter(kind, ...args) {\n    this.callbacks[`after${kind}`].forEach((callback) => callback(...args));\n  }\n  markPrunableContentForRemoval() {\n    const phxUpdate = this.liveSocket.binding(PHX_UPDATE);\n    dom_default.all(\n      this.container,\n      `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`,\n      (el) => {\n        el.setAttribute(PHX_PRUNE, \"\");\n      }\n    );\n  }\n  perform(isJoinPatch) {\n    const { view, liveSocket, html, container } = this;\n    let targetContainer = this.targetContainer;\n    if (this.isCIDPatch() && !this.targetContainer) {\n      return;\n    }\n    if (this.isCIDPatch()) {\n      const closestLock = targetContainer.closest(`[${PHX_REF_LOCK}]`);\n      if (closestLock) {\n        const clonedTree = dom_default.private(closestLock, PHX_REF_LOCK);\n        if (clonedTree) {\n          targetContainer = clonedTree.querySelector(\n            `[data-phx-component=\"${this.targetCID}\"]`\n          );\n        }\n      }\n    }\n    const focused = liveSocket.getActiveElement();\n    const { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};\n    const phxUpdate = liveSocket.binding(PHX_UPDATE);\n    const phxViewportTop = liveSocket.binding(PHX_VIEWPORT_TOP);\n    const phxViewportBottom = liveSocket.binding(PHX_VIEWPORT_BOTTOM);\n    const phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\n    const added = [];\n    const updates = [];\n    const appendPrependUpdates = [];\n    const portalCallbacks = [];\n    let externalFormTriggered = null;\n    const morph = (targetContainer2, source, withChildren = this.withChildren) => {\n      const morphCallbacks = {\n        // normally, we are running with childrenOnly, as the patch HTML for a LV\n        // does not include the LV attrs (data-phx-session, etc.)\n        // when we are patching a live component, we do want to patch the root element as well;\n        // another case is the recursive patch of a stream item that was kept on reset (-> onBeforeNodeAdded)\n        childrenOnly: targetContainer2.getAttribute(PHX_COMPONENT) === null && !withChildren,\n        getNodeKey: (node) => {\n          if (dom_default.isPhxDestroyed(node)) {\n            return null;\n          }\n          if (isJoinPatch) {\n            return node.id;\n          }\n          return node.id || node.getAttribute && node.getAttribute(PHX_MAGIC_ID);\n        },\n        // skip indexing from children when container is stream\n        skipFromChildren: (from) => {\n          return from.getAttribute(phxUpdate) === PHX_STREAM;\n        },\n        // tell morphdom how to add a child\n        addChild: (parent, child) => {\n          const { ref, streamAt } = this.getStreamInsert(child);\n          if (ref === void 0) {\n            return parent.appendChild(child);\n          }\n          this.setStreamRef(child, ref);\n          if (streamAt === 0) {\n            parent.insertAdjacentElement(\"afterbegin\", child);\n          } else if (streamAt === -1) {\n            const lastChild = parent.lastElementChild;\n            if (lastChild && !lastChild.hasAttribute(PHX_STREAM_REF)) {\n              const nonStreamChild = Array.from(parent.children).find(\n                (c) => !c.hasAttribute(PHX_STREAM_REF)\n              );\n              parent.insertBefore(child, nonStreamChild);\n            } else {\n              parent.appendChild(child);\n            }\n          } else if (streamAt > 0) {\n            const sibling = Array.from(parent.children)[streamAt];\n            parent.insertBefore(child, sibling);\n          }\n        },\n        onBeforeNodeAdded: (el) => {\n          if (this.getStreamInsert(el)?.updateOnly && !this.streamComponentRestore[el.id]) {\n            return false;\n          }\n          dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);\n          this.trackBefore(\"added\", el);\n          let morphedEl = el;\n          if (this.streamComponentRestore[el.id]) {\n            morphedEl = this.streamComponentRestore[el.id];\n            delete this.streamComponentRestore[el.id];\n            morph(morphedEl, el, true);\n          }\n          return morphedEl;\n        },\n        onNodeAdded: (el) => {\n          if (el.getAttribute) {\n            this.maybeReOrderStream(el, true);\n          }\n          if (dom_default.isPortalTemplate(el)) {\n            portalCallbacks.push(() => this.teleport(el, morph));\n          }\n          if (el instanceof HTMLImageElement && el.srcset) {\n            el.srcset = el.srcset;\n          } else if (el instanceof HTMLVideoElement && el.autoplay) {\n            el.play();\n          }\n          if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n            externalFormTriggered = el;\n          }\n          if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {\n            this.trackAfter(\"phxChildAdded\", el);\n          }\n          if (el.nodeName === \"SCRIPT\" && el.hasAttribute(PHX_RUNTIME_HOOK)) {\n            this.handleRuntimeHook(el, source);\n          }\n          added.push(el);\n        },\n        onNodeDiscarded: (el) => this.onNodeDiscarded(el),\n        onBeforeNodeDiscarded: (el) => {\n          if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {\n            return true;\n          }\n          if (el.parentElement !== null && el.id && dom_default.isPhxUpdate(el.parentElement, phxUpdate, [\n            PHX_STREAM,\n            \"append\",\n            \"prepend\"\n          ])) {\n            return false;\n          }\n          if (el.getAttribute && el.getAttribute(PHX_TELEPORTED_REF)) {\n            return false;\n          }\n          if (this.maybePendingRemove(el)) {\n            return false;\n          }\n          if (this.skipCIDSibling(el)) {\n            return false;\n          }\n          if (dom_default.isPortalTemplate(el)) {\n            const teleportedEl = document.getElementById(\n              el.content.firstElementChild.id\n            );\n            if (teleportedEl) {\n              teleportedEl.remove();\n              morphCallbacks.onNodeDiscarded(teleportedEl);\n              this.view.dropPortalElementId(teleportedEl.id);\n            }\n          }\n          return true;\n        },\n        onElUpdated: (el) => {\n          if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n            externalFormTriggered = el;\n          }\n          updates.push(el);\n          this.maybeReOrderStream(el, false);\n        },\n        onBeforeElUpdated: (fromEl, toEl) => {\n          if (fromEl.id && fromEl.isSameNode(targetContainer2) && fromEl.id !== toEl.id) {\n            morphCallbacks.onNodeDiscarded(fromEl);\n            fromEl.replaceWith(toEl);\n            return morphCallbacks.onNodeAdded(toEl);\n          }\n          dom_default.syncPendingAttrs(fromEl, toEl);\n          dom_default.maintainPrivateHooks(\n            fromEl,\n            toEl,\n            phxViewportTop,\n            phxViewportBottom\n          );\n          dom_default.cleanChildNodes(toEl, phxUpdate);\n          if (this.skipCIDSibling(toEl)) {\n            this.maybeReOrderStream(fromEl);\n            return false;\n          }\n          if (dom_default.isPhxSticky(fromEl)) {\n            [PHX_SESSION, PHX_STATIC, PHX_ROOT_ID].map((attr) => [\n              attr,\n              fromEl.getAttribute(attr),\n              toEl.getAttribute(attr)\n            ]).forEach(([attr, fromVal, toVal]) => {\n              if (toVal && fromVal !== toVal) {\n                fromEl.setAttribute(attr, toVal);\n              }\n            });\n            return false;\n          }\n          if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {\n            this.trackBefore(\"updated\", fromEl, toEl);\n            dom_default.mergeAttrs(fromEl, toEl, {\n              isIgnored: dom_default.isIgnored(fromEl, phxUpdate)\n            });\n            updates.push(fromEl);\n            dom_default.applyStickyOperations(fromEl);\n            return false;\n          }\n          if (fromEl.type === \"number\" && fromEl.validity && fromEl.validity.badInput) {\n            return false;\n          }\n          const isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);\n          const focusedSelectChanged = isFocusedFormEl && this.isChangedSelect(fromEl, toEl);\n          if (fromEl.hasAttribute(PHX_REF_SRC)) {\n            const ref = new ElementRef(fromEl);\n            if (ref.lockRef && (!this.undoRef || !ref.isLockUndoneBy(this.undoRef))) {\n              if (dom_default.isUploadInput(fromEl)) {\n                dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });\n                this.trackBefore(\"updated\", fromEl, toEl);\n                updates.push(fromEl);\n              }\n              dom_default.applyStickyOperations(fromEl);\n              const isLocked = fromEl.hasAttribute(PHX_REF_LOCK);\n              const clone2 = isLocked ? dom_default.private(fromEl, PHX_REF_LOCK) || fromEl.cloneNode(true) : null;\n              if (clone2) {\n                dom_default.putPrivate(fromEl, PHX_REF_LOCK, clone2);\n                if (!isFocusedFormEl) {\n                  fromEl = clone2;\n                }\n              }\n            }\n          }\n          if (dom_default.isPhxChild(toEl)) {\n            const prevSession = fromEl.getAttribute(PHX_SESSION);\n            dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });\n            if (prevSession !== \"\") {\n              fromEl.setAttribute(PHX_SESSION, prevSession);\n            }\n            fromEl.setAttribute(PHX_ROOT_ID, this.rootID);\n            dom_default.applyStickyOperations(fromEl);\n            return false;\n          }\n          if (this.undoRef && dom_default.private(toEl, PHX_REF_LOCK)) {\n            dom_default.putPrivate(\n              fromEl,\n              PHX_REF_LOCK,\n              dom_default.private(toEl, PHX_REF_LOCK)\n            );\n          }\n          dom_default.copyPrivates(toEl, fromEl);\n          if (dom_default.isPortalTemplate(toEl)) {\n            portalCallbacks.push(() => this.teleport(toEl, morph));\n            return false;\n          }\n          if (isFocusedFormEl && fromEl.type !== \"hidden\" && !focusedSelectChanged) {\n            this.trackBefore(\"updated\", fromEl, toEl);\n            dom_default.mergeFocusedInput(fromEl, toEl);\n            dom_default.syncAttrsToProps(fromEl);\n            updates.push(fromEl);\n            dom_default.applyStickyOperations(fromEl);\n            return false;\n          } else {\n            if (focusedSelectChanged) {\n              fromEl.blur();\n            }\n            if (dom_default.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\n              appendPrependUpdates.push(\n                new DOMPostMorphRestorer(\n                  fromEl,\n                  toEl,\n                  toEl.getAttribute(phxUpdate)\n                )\n              );\n            }\n            dom_default.syncAttrsToProps(toEl);\n            dom_default.applyStickyOperations(toEl);\n            this.trackBefore(\"updated\", fromEl, toEl);\n            return fromEl;\n          }\n        }\n      };\n      morphdom_esm_default(targetContainer2, source, morphCallbacks);\n    };\n    this.trackBefore(\"added\", container);\n    this.trackBefore(\"updated\", container, container);\n    liveSocket.time(\"morphdom\", () => {\n      this.streams.forEach(([ref, inserts, deleteIds, reset]) => {\n        inserts.forEach(([key, streamAt, limit, updateOnly]) => {\n          this.streamInserts[key] = { ref, streamAt, limit, reset, updateOnly };\n        });\n        if (reset !== void 0) {\n          dom_default.all(container, `[${PHX_STREAM_REF}=\"${ref}\"]`, (child) => {\n            this.removeStreamChildElement(child);\n          });\n        }\n        deleteIds.forEach((id) => {\n          const child = container.querySelector(`[id=\"${id}\"]`);\n          if (child) {\n            this.removeStreamChildElement(child);\n          }\n        });\n      });\n      if (isJoinPatch) {\n        dom_default.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`).filter((el) => this.view.ownsElement(el)).forEach((el) => {\n          Array.from(el.children).forEach((child) => {\n            this.removeStreamChildElement(child, true);\n          });\n        });\n      }\n      morph(targetContainer, html);\n      portalCallbacks.forEach((callback) => callback());\n      this.view.portalElementIds.forEach((id) => {\n        const el = document.getElementById(id);\n        if (el) {\n          const source = document.getElementById(\n            el.getAttribute(PHX_TELEPORTED_SRC)\n          );\n          if (!source) {\n            el.remove();\n            this.onNodeDiscarded(el);\n            this.view.dropPortalElementId(id);\n          }\n        }\n      });\n    });\n    if (liveSocket.isDebugEnabled()) {\n      detectDuplicateIds();\n      detectInvalidStreamInserts(this.streamInserts);\n      Array.from(document.querySelectorAll(\"input[name=id]\")).forEach(\n        (node) => {\n          if (node instanceof HTMLInputElement && node.form) {\n            console.error(\n              'Detected an input with name=\"id\" inside a form! This will cause problems when patching the DOM.\\n',\n              node\n            );\n          }\n        }\n      );\n    }\n    if (appendPrependUpdates.length > 0) {\n      liveSocket.time(\"post-morph append/prepend restoration\", () => {\n        appendPrependUpdates.forEach((update) => update.perform());\n      });\n    }\n    liveSocket.silenceEvents(\n      () => dom_default.restoreFocus(focused, selectionStart, selectionEnd)\n    );\n    dom_default.dispatchEvent(document, \"phx:update\");\n    added.forEach((el) => this.trackAfter(\"added\", el));\n    updates.forEach((el) => this.trackAfter(\"updated\", el));\n    this.transitionPendingRemoves();\n    if (externalFormTriggered) {\n      liveSocket.unload();\n      const submitter = dom_default.private(externalFormTriggered, \"submitter\");\n      if (submitter && submitter.name && targetContainer.contains(submitter)) {\n        const input = document.createElement(\"input\");\n        input.type = \"hidden\";\n        const formId = submitter.getAttribute(\"form\");\n        if (formId) {\n          input.setAttribute(\"form\", formId);\n        }\n        input.name = submitter.name;\n        input.value = submitter.value;\n        submitter.parentElement.insertBefore(input, submitter);\n      }\n      Object.getPrototypeOf(externalFormTriggered).submit.call(\n        externalFormTriggered\n      );\n    }\n    return true;\n  }\n  onNodeDiscarded(el) {\n    if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {\n      this.liveSocket.destroyViewByEl(el);\n    }\n    this.trackAfter(\"discarded\", el);\n  }\n  maybePendingRemove(node) {\n    if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {\n      this.pendingRemoves.push(node);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  removeStreamChildElement(child, force = false) {\n    if (!force && !this.view.ownsElement(child)) {\n      return;\n    }\n    if (this.streamInserts[child.id]) {\n      this.streamComponentRestore[child.id] = child;\n      child.remove();\n    } else {\n      if (!this.maybePendingRemove(child)) {\n        child.remove();\n        this.onNodeDiscarded(child);\n      }\n    }\n  }\n  getStreamInsert(el) {\n    const insert = el.id ? this.streamInserts[el.id] : {};\n    return insert || {};\n  }\n  setStreamRef(el, ref) {\n    dom_default.putSticky(\n      el,\n      PHX_STREAM_REF,\n      (el2) => el2.setAttribute(PHX_STREAM_REF, ref)\n    );\n  }\n  maybeReOrderStream(el, isNew) {\n    const { ref, streamAt, reset } = this.getStreamInsert(el);\n    if (streamAt === void 0) {\n      return;\n    }\n    this.setStreamRef(el, ref);\n    if (!reset && !isNew) {\n      return;\n    }\n    if (!el.parentElement) {\n      return;\n    }\n    if (streamAt === 0) {\n      el.parentElement.insertBefore(el, el.parentElement.firstElementChild);\n    } else if (streamAt > 0) {\n      const children = Array.from(el.parentElement.children);\n      const oldIndex = children.indexOf(el);\n      if (streamAt >= children.length - 1) {\n        el.parentElement.appendChild(el);\n      } else {\n        const sibling = children[streamAt];\n        if (oldIndex > streamAt) {\n          el.parentElement.insertBefore(el, sibling);\n        } else {\n          el.parentElement.insertBefore(el, sibling.nextElementSibling);\n        }\n      }\n    }\n    this.maybeLimitStream(el);\n  }\n  maybeLimitStream(el) {\n    const { limit } = this.getStreamInsert(el);\n    const children = limit !== null && Array.from(el.parentElement.children);\n    if (limit && limit < 0 && children.length > limit * -1) {\n      children.slice(0, children.length + limit).forEach((child) => this.removeStreamChildElement(child));\n    } else if (limit && limit >= 0 && children.length > limit) {\n      children.slice(limit).forEach((child) => this.removeStreamChildElement(child));\n    }\n  }\n  transitionPendingRemoves() {\n    const { pendingRemoves, liveSocket } = this;\n    if (pendingRemoves.length > 0) {\n      liveSocket.transitionRemoves(pendingRemoves, () => {\n        pendingRemoves.forEach((el) => {\n          const child = dom_default.firstPhxChild(el);\n          if (child) {\n            liveSocket.destroyViewByEl(child);\n          }\n          el.remove();\n        });\n        this.trackAfter(\"transitionsDiscarded\", pendingRemoves);\n      });\n    }\n  }\n  isChangedSelect(fromEl, toEl) {\n    if (!(fromEl instanceof HTMLSelectElement) || fromEl.multiple) {\n      return false;\n    }\n    if (fromEl.options.length !== toEl.options.length) {\n      return true;\n    }\n    toEl.value = fromEl.value;\n    return !fromEl.isEqualNode(toEl);\n  }\n  isCIDPatch() {\n    return this.cidPatch;\n  }\n  skipCIDSibling(el) {\n    return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(PHX_SKIP);\n  }\n  targetCIDContainer(html) {\n    if (!this.isCIDPatch()) {\n      return;\n    }\n    const [first, ...rest] = dom_default.findComponentNodeList(\n      this.view.id,\n      this.targetCID\n    );\n    if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {\n      return first;\n    } else {\n      return first && first.parentNode;\n    }\n  }\n  indexOf(parent, child) {\n    return Array.from(parent.children).indexOf(child);\n  }\n  teleport(el, morph) {\n    const targetSelector = el.getAttribute(PHX_PORTAL);\n    const portalContainer = document.querySelector(targetSelector);\n    if (!portalContainer) {\n      throw new Error(\n        \"portal target with selector \" + targetSelector + \" not found\"\n      );\n    }\n    const toTeleport = el.content.firstElementChild;\n    if (this.skipCIDSibling(toTeleport)) {\n      return;\n    }\n    if (!toTeleport?.id) {\n      throw new Error(\n        \"phx-portal template must have a single root element with ID!\"\n      );\n    }\n    const existing = document.getElementById(toTeleport.id);\n    let portalTarget;\n    if (existing) {\n      if (!portalContainer.contains(existing)) {\n        portalContainer.appendChild(existing);\n      }\n      portalTarget = existing;\n    } else {\n      portalTarget = document.createElement(toTeleport.tagName);\n      portalContainer.appendChild(portalTarget);\n    }\n    toTeleport.setAttribute(PHX_TELEPORTED_REF, this.view.id);\n    toTeleport.setAttribute(PHX_TELEPORTED_SRC, el.id);\n    morph(portalTarget, toTeleport, true);\n    toTeleport.removeAttribute(PHX_TELEPORTED_REF);\n    toTeleport.removeAttribute(PHX_TELEPORTED_SRC);\n    this.view.pushPortalElementId(toTeleport.id);\n  }\n  handleRuntimeHook(el, source) {\n    const name = el.getAttribute(PHX_RUNTIME_HOOK);\n    let nonce = el.hasAttribute(\"nonce\") ? el.getAttribute(\"nonce\") : null;\n    if (el.hasAttribute(\"nonce\")) {\n      const template = document.createElement(\"template\");\n      template.innerHTML = source;\n      nonce = template.content.querySelector(`script[${PHX_RUNTIME_HOOK}=\"${CSS.escape(name)}\"]`).getAttribute(\"nonce\");\n    }\n    const script = document.createElement(\"script\");\n    script.textContent = el.textContent;\n    dom_default.mergeAttrs(script, el, { isIgnored: false });\n    if (nonce) {\n      script.nonce = nonce;\n    }\n    el.replaceWith(script);\n    el = script;\n  }\n};\n\n// js/phoenix_live_view/rendered.js\nvar VOID_TAGS = /* @__PURE__ */ new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"command\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n]);\nvar quoteChars = /* @__PURE__ */ new Set([\"'\", '\"']);\nvar modifyRoot = (html, attrs, clearInnerHTML) => {\n  let i = 0;\n  let insideComment = false;\n  let beforeTag, afterTag, tag, tagNameEndsAt, id, newHTML;\n  const lookahead = html.match(/^(\\s*(?:<!--.*?-->\\s*)*)<([^\\s\\/>]+)/);\n  if (lookahead === null) {\n    throw new Error(`malformed html ${html}`);\n  }\n  i = lookahead[0].length;\n  beforeTag = lookahead[1];\n  tag = lookahead[2];\n  tagNameEndsAt = i;\n  for (i; i < html.length; i++) {\n    if (html.charAt(i) === \">\") {\n      break;\n    }\n    if (html.charAt(i) === \"=\") {\n      const isId = html.slice(i - 3, i) === \" id\";\n      i++;\n      const char = html.charAt(i);\n      if (quoteChars.has(char)) {\n        const attrStartsAt = i;\n        i++;\n        for (i; i < html.length; i++) {\n          if (html.charAt(i) === char) {\n            break;\n          }\n        }\n        if (isId) {\n          id = html.slice(attrStartsAt + 1, i);\n          break;\n        }\n      }\n    }\n  }\n  let closeAt = html.length - 1;\n  insideComment = false;\n  while (closeAt >= beforeTag.length + tag.length) {\n    const char = html.charAt(closeAt);\n    if (insideComment) {\n      if (char === \"-\" && html.slice(closeAt - 3, closeAt) === \"<!-\") {\n        insideComment = false;\n        closeAt -= 4;\n      } else {\n        closeAt -= 1;\n      }\n    } else if (char === \">\" && html.slice(closeAt - 2, closeAt) === \"--\") {\n      insideComment = true;\n      closeAt -= 3;\n    } else if (char === \">\") {\n      break;\n    } else {\n      closeAt -= 1;\n    }\n  }\n  afterTag = html.slice(closeAt + 1, html.length);\n  const attrsStr = Object.keys(attrs).map((attr) => attrs[attr] === true ? attr : `${attr}=\"${attrs[attr]}\"`).join(\" \");\n  if (clearInnerHTML) {\n    const idAttrStr = id ? ` id=\"${id}\"` : \"\";\n    if (VOID_TAGS.has(tag)) {\n      newHTML = `<${tag}${idAttrStr}${attrsStr === \"\" ? \"\" : \" \"}${attrsStr}/>`;\n    } else {\n      newHTML = `<${tag}${idAttrStr}${attrsStr === \"\" ? \"\" : \" \"}${attrsStr}></${tag}>`;\n    }\n  } else {\n    const rest = html.slice(tagNameEndsAt, closeAt + 1);\n    newHTML = `<${tag}${attrsStr === \"\" ? \"\" : \" \"}${attrsStr}${rest}`;\n  }\n  return [newHTML, beforeTag, afterTag];\n};\nvar Rendered = class {\n  static extract(diff) {\n    const { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;\n    delete diff[REPLY];\n    delete diff[EVENTS];\n    delete diff[TITLE];\n    return { diff, title, reply: reply || null, events: events || [] };\n  }\n  constructor(viewId, rendered) {\n    this.viewId = viewId;\n    this.rendered = {};\n    this.magicId = 0;\n    this.mergeDiff(rendered);\n  }\n  parentViewId() {\n    return this.viewId;\n  }\n  toString(onlyCids) {\n    const { buffer: str, streams } = this.recursiveToString(\n      this.rendered,\n      this.rendered[COMPONENTS],\n      onlyCids,\n      true,\n      {}\n    );\n    return { buffer: str, streams };\n  }\n  recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids, changeTracking, rootAttrs) {\n    onlyCids = onlyCids ? new Set(onlyCids) : null;\n    const output = {\n      buffer: \"\",\n      components,\n      onlyCids,\n      streams: /* @__PURE__ */ new Set()\n    };\n    this.toOutputBuffer(rendered, null, output, changeTracking, rootAttrs);\n    return { buffer: output.buffer, streams: output.streams };\n  }\n  componentCIDs(diff) {\n    return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));\n  }\n  isComponentOnlyDiff(diff) {\n    if (!diff[COMPONENTS]) {\n      return false;\n    }\n    return Object.keys(diff).length === 1;\n  }\n  getComponent(diff, cid) {\n    return diff[COMPONENTS][cid];\n  }\n  resetRender(cid) {\n    if (this.rendered[COMPONENTS][cid]) {\n      this.rendered[COMPONENTS][cid].reset = true;\n    }\n  }\n  mergeDiff(diff) {\n    const newc = diff[COMPONENTS];\n    const cache = {};\n    delete diff[COMPONENTS];\n    this.rendered = this.mutableMerge(this.rendered, diff);\n    this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\n    if (newc) {\n      const oldc = this.rendered[COMPONENTS];\n      for (const cid in newc) {\n        newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);\n      }\n      for (const cid in newc) {\n        oldc[cid] = newc[cid];\n      }\n      diff[COMPONENTS] = newc;\n    }\n  }\n  cachedFindComponent(cid, cdiff, oldc, newc, cache) {\n    if (cache[cid]) {\n      return cache[cid];\n    } else {\n      let ndiff, stat, scid = cdiff[STATIC];\n      if (isCid(scid)) {\n        let tdiff;\n        if (scid > 0) {\n          tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);\n        } else {\n          tdiff = oldc[-scid];\n        }\n        stat = tdiff[STATIC];\n        ndiff = this.cloneMerge(tdiff, cdiff, true);\n        ndiff[STATIC] = stat;\n      } else {\n        ndiff = cdiff[STATIC] !== void 0 || oldc[cid] === void 0 ? cdiff : this.cloneMerge(oldc[cid], cdiff, false);\n      }\n      cache[cid] = ndiff;\n      return ndiff;\n    }\n  }\n  mutableMerge(target, source) {\n    if (source[STATIC] !== void 0) {\n      return source;\n    } else {\n      this.doMutableMerge(target, source);\n      return target;\n    }\n  }\n  doMutableMerge(target, source) {\n    if (source[KEYED]) {\n      this.mergeKeyed(target, source);\n    } else {\n      for (const key in source) {\n        const val = source[key];\n        const targetVal = target[key];\n        const isObjVal = isObject(val);\n        if (isObjVal && val[STATIC] === void 0 && isObject(targetVal)) {\n          this.doMutableMerge(targetVal, val);\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n    if (target[ROOT]) {\n      target.newRender = true;\n    }\n  }\n  clone(diff) {\n    if (\"structuredClone\" in window) {\n      return structuredClone(diff);\n    } else {\n      return JSON.parse(JSON.stringify(diff));\n    }\n  }\n  // keyed comprehensions\n  mergeKeyed(target, source) {\n    const clonedTarget = this.clone(target);\n    Object.entries(source[KEYED]).forEach(([i, entry]) => {\n      if (i === KEYED_COUNT) {\n        return;\n      }\n      if (Array.isArray(entry)) {\n        const [old_idx, diff] = entry;\n        target[KEYED][i] = clonedTarget[KEYED][old_idx];\n        this.doMutableMerge(target[KEYED][i], diff);\n      } else if (typeof entry === \"number\") {\n        const old_idx = entry;\n        target[KEYED][i] = clonedTarget[KEYED][old_idx];\n      } else if (typeof entry === \"object\") {\n        if (!target[KEYED][i]) {\n          target[KEYED][i] = {};\n        }\n        this.doMutableMerge(target[KEYED][i], entry);\n      }\n    });\n    if (source[KEYED][KEYED_COUNT] < target[KEYED][KEYED_COUNT]) {\n      for (let i = source[KEYED][KEYED_COUNT]; i < target[KEYED][KEYED_COUNT]; i++) {\n        delete target[KEYED][i];\n      }\n    }\n    target[KEYED][KEYED_COUNT] = source[KEYED][KEYED_COUNT];\n    if (source[STREAM]) {\n      target[STREAM] = source[STREAM];\n    }\n    if (source[TEMPLATES]) {\n      target[TEMPLATES] = source[TEMPLATES];\n    }\n  }\n  // Merges cid trees together, copying statics from source tree.\n  //\n  // The `pruneMagicId` is passed to control pruning the magicId of the\n  // target. We must always prune the magicId when we are sharing statics\n  // from another component. If not pruning, we replicate the logic from\n  // mutableMerge, where we set newRender to true if there is a root\n  // (effectively forcing the new version to be rendered instead of skipped)\n  //\n  cloneMerge(target, source, pruneMagicId) {\n    const merged = { ...target, ...source };\n    for (const key in merged) {\n      const val = source[key];\n      const targetVal = target[key];\n      if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n        merged[key] = this.cloneMerge(targetVal, val, pruneMagicId);\n      } else if (val === void 0 && isObject(targetVal)) {\n        merged[key] = this.cloneMerge(targetVal, {}, pruneMagicId);\n      }\n    }\n    if (pruneMagicId) {\n      delete merged.magicId;\n      delete merged.newRender;\n    } else if (target[ROOT]) {\n      merged.newRender = true;\n    }\n    return merged;\n  }\n  componentToString(cid) {\n    const { buffer: str, streams } = this.recursiveCIDToString(\n      this.rendered[COMPONENTS],\n      cid,\n      null\n    );\n    const [strippedHTML, _before, _after] = modifyRoot(str, {});\n    return { buffer: strippedHTML, streams };\n  }\n  pruneCIDs(cids) {\n    cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);\n  }\n  // private\n  get() {\n    return this.rendered;\n  }\n  isNewFingerprint(diff = {}) {\n    return !!diff[STATIC];\n  }\n  templateStatic(part, templates) {\n    if (typeof part === \"number\") {\n      return templates[part];\n    } else {\n      return part;\n    }\n  }\n  nextMagicID() {\n    this.magicId++;\n    return `m${this.magicId}-${this.parentViewId()}`;\n  }\n  // Converts rendered tree to output buffer.\n  //\n  // changeTracking controls if we can apply the PHX_SKIP optimization.\n  toOutputBuffer(rendered, templates, output, changeTracking, rootAttrs = {}) {\n    if (rendered[KEYED]) {\n      return this.comprehensionToBuffer(\n        rendered,\n        templates,\n        output,\n        changeTracking\n      );\n    }\n    if (rendered[TEMPLATES]) {\n      templates = rendered[TEMPLATES];\n      delete rendered[TEMPLATES];\n    }\n    let { [STATIC]: statics } = rendered;\n    statics = this.templateStatic(statics, templates);\n    rendered[STATIC] = statics;\n    const isRoot = rendered[ROOT];\n    const prevBuffer = output.buffer;\n    if (isRoot) {\n      output.buffer = \"\";\n    }\n    if (changeTracking && isRoot && !rendered.magicId) {\n      rendered.newRender = true;\n      rendered.magicId = this.nextMagicID();\n    }\n    output.buffer += statics[0];\n    for (let i = 1; i < statics.length; i++) {\n      this.dynamicToBuffer(rendered[i - 1], templates, output, changeTracking);\n      output.buffer += statics[i];\n    }\n    if (isRoot) {\n      let skip = false;\n      let attrs;\n      if (changeTracking || rendered.magicId) {\n        skip = changeTracking && !rendered.newRender;\n        attrs = { [PHX_MAGIC_ID]: rendered.magicId, ...rootAttrs };\n      } else {\n        attrs = rootAttrs;\n      }\n      if (skip) {\n        attrs[PHX_SKIP] = true;\n      }\n      const [newRoot, commentBefore, commentAfter] = modifyRoot(\n        output.buffer,\n        attrs,\n        skip\n      );\n      rendered.newRender = false;\n      output.buffer = prevBuffer + commentBefore + newRoot + commentAfter;\n    }\n  }\n  comprehensionToBuffer(rendered, templates, output, changeTracking) {\n    const keyedTemplates = templates || rendered[TEMPLATES];\n    const statics = this.templateStatic(rendered[STATIC], templates);\n    rendered[STATIC] = statics;\n    delete rendered[TEMPLATES];\n    for (let i = 0; i < rendered[KEYED][KEYED_COUNT]; i++) {\n      output.buffer += statics[0];\n      for (let j = 1; j < statics.length; j++) {\n        this.dynamicToBuffer(\n          rendered[KEYED][i][j - 1],\n          keyedTemplates,\n          output,\n          changeTracking\n        );\n        output.buffer += statics[j];\n      }\n    }\n    if (rendered[STREAM]) {\n      const stream = rendered[STREAM];\n      const [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];\n      if (stream !== void 0 && (rendered[KEYED][KEYED_COUNT] > 0 || deleteIds.length > 0 || reset)) {\n        delete rendered[STREAM];\n        rendered[KEYED] = {\n          [KEYED_COUNT]: 0\n        };\n        output.streams.add(stream);\n      }\n    }\n  }\n  dynamicToBuffer(rendered, templates, output, changeTracking) {\n    if (typeof rendered === \"number\") {\n      const { buffer: str, streams } = this.recursiveCIDToString(\n        output.components,\n        rendered,\n        output.onlyCids\n      );\n      output.buffer += str;\n      output.streams = /* @__PURE__ */ new Set([...output.streams, ...streams]);\n    } else if (isObject(rendered)) {\n      this.toOutputBuffer(rendered, templates, output, changeTracking, {});\n    } else {\n      output.buffer += rendered;\n    }\n  }\n  recursiveCIDToString(components, cid, onlyCids) {\n    const component = components[cid] || logError(`no component for CID ${cid}`, components);\n    const attrs = { [PHX_COMPONENT]: cid, [PHX_VIEW_REF]: this.viewId };\n    const skip = onlyCids && !onlyCids.has(cid);\n    component.newRender = !skip;\n    component.magicId = `c${cid}-${this.parentViewId()}`;\n    const changeTracking = !component.reset;\n    const { buffer: html, streams } = this.recursiveToString(\n      component,\n      components,\n      onlyCids,\n      changeTracking,\n      attrs\n    );\n    delete component.reset;\n    return { buffer: html, streams };\n  }\n};\n\n// js/phoenix_live_view/js.js\nvar focusStack = [];\nvar default_transition_time = 200;\nvar JS = {\n  // private\n  exec(e, eventType, phxEvent, view, sourceEl, defaults) {\n    const [defaultKind, defaultArgs] = defaults || [\n      null,\n      { callback: defaults && defaults.callback }\n    ];\n    const commands = phxEvent.charAt(0) === \"[\" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];\n    commands.forEach(([kind, args]) => {\n      if (kind === defaultKind) {\n        args = { ...defaultArgs, ...args };\n        args.callback = args.callback || defaultArgs.callback;\n      }\n      this.filterToEls(view.liveSocket, sourceEl, args).forEach((el) => {\n        this[`exec_${kind}`](e, eventType, phxEvent, view, sourceEl, el, args);\n      });\n    });\n  },\n  isVisible(el) {\n    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);\n  },\n  // returns true if any part of the element is inside the viewport\n  isInViewport(el) {\n    const rect = el.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    return rect.right > 0 && rect.bottom > 0 && rect.left < windowWidth && rect.top < windowHeight;\n  },\n  // private\n  // commands\n  exec_exec(e, eventType, phxEvent, view, sourceEl, el, { attr, to }) {\n    const encodedJS = el.getAttribute(attr);\n    if (!encodedJS) {\n      throw new Error(`expected ${attr} to contain JS command on \"${to}\"`);\n    }\n    view.liveSocket.execJS(el, encodedJS, eventType);\n  },\n  exec_dispatch(e, eventType, phxEvent, view, sourceEl, el, { event, detail, bubbles, blocking }) {\n    detail = detail || {};\n    detail.dispatcher = sourceEl;\n    if (blocking) {\n      const promise = new Promise((resolve, _reject) => {\n        detail.done = resolve;\n      });\n      view.liveSocket.asyncTransition(promise);\n    }\n    dom_default.dispatchEvent(el, event, { detail, bubbles });\n  },\n  exec_push(e, eventType, phxEvent, view, sourceEl, el, args) {\n    const {\n      event,\n      data,\n      target,\n      page_loading,\n      loading,\n      value,\n      dispatcher,\n      callback\n    } = args;\n    const pushOpts = {\n      loading,\n      value,\n      target,\n      page_loading: !!page_loading,\n      originalEvent: e\n    };\n    const targetSrc = eventType === \"change\" && dispatcher ? dispatcher : sourceEl;\n    const phxTarget = target || targetSrc.getAttribute(view.binding(\"target\")) || targetSrc;\n    const handler = (targetView, targetCtx) => {\n      if (!targetView.isConnected()) {\n        return;\n      }\n      if (eventType === \"change\") {\n        let { newCid, _target } = args;\n        _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);\n        if (_target) {\n          pushOpts._target = _target;\n        }\n        targetView.pushInput(\n          sourceEl,\n          targetCtx,\n          newCid,\n          event || phxEvent,\n          pushOpts,\n          callback\n        );\n      } else if (eventType === \"submit\") {\n        const { submitter } = args;\n        targetView.submitForm(\n          sourceEl,\n          targetCtx,\n          event || phxEvent,\n          submitter,\n          pushOpts,\n          callback\n        );\n      } else {\n        targetView.pushEvent(\n          eventType,\n          sourceEl,\n          targetCtx,\n          event || phxEvent,\n          data,\n          pushOpts,\n          callback\n        );\n      }\n    };\n    if (args.targetView && args.targetCtx) {\n      handler(args.targetView, args.targetCtx);\n    } else {\n      view.withinTargets(phxTarget, handler);\n    }\n  },\n  exec_navigate(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {\n    view.liveSocket.historyRedirect(\n      e,\n      href,\n      replace ? \"replace\" : \"push\",\n      null,\n      sourceEl\n    );\n  },\n  exec_patch(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {\n    view.liveSocket.pushHistoryPatch(\n      e,\n      href,\n      replace ? \"replace\" : \"push\",\n      sourceEl\n    );\n  },\n  exec_focus(e, eventType, phxEvent, view, sourceEl, el) {\n    aria_default.attemptFocus(el);\n    window.requestAnimationFrame(() => {\n      window.requestAnimationFrame(() => aria_default.attemptFocus(el));\n    });\n  },\n  exec_focus_first(e, eventType, phxEvent, view, sourceEl, el) {\n    aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el);\n    window.requestAnimationFrame(() => {\n      window.requestAnimationFrame(\n        () => aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el)\n      );\n    });\n  },\n  exec_push_focus(e, eventType, phxEvent, view, sourceEl, el) {\n    focusStack.push(el || sourceEl);\n  },\n  exec_pop_focus(_e, _eventType, _phxEvent, _view, _sourceEl, _el) {\n    const el = focusStack.pop();\n    if (el) {\n      el.focus();\n      window.requestAnimationFrame(() => {\n        window.requestAnimationFrame(() => el.focus());\n      });\n    }\n  },\n  exec_add_class(e, eventType, phxEvent, view, sourceEl, el, { names, transition, time, blocking }) {\n    this.addOrRemoveClasses(el, names, [], transition, time, view, blocking);\n  },\n  exec_remove_class(e, eventType, phxEvent, view, sourceEl, el, { names, transition, time, blocking }) {\n    this.addOrRemoveClasses(el, [], names, transition, time, view, blocking);\n  },\n  exec_toggle_class(e, eventType, phxEvent, view, sourceEl, el, { names, transition, time, blocking }) {\n    this.toggleClasses(el, names, transition, time, view, blocking);\n  },\n  exec_toggle_attr(e, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val1, val2] }) {\n    this.toggleAttr(el, attr, val1, val2);\n  },\n  exec_ignore_attrs(e, eventType, phxEvent, view, sourceEl, el, { attrs }) {\n    this.ignoreAttrs(el, attrs);\n  },\n  exec_transition(e, eventType, phxEvent, view, sourceEl, el, { time, transition, blocking }) {\n    this.addOrRemoveClasses(el, [], [], transition, time, view, blocking);\n  },\n  exec_toggle(e, eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time, blocking }) {\n    this.toggle(eventType, view, el, display, ins, outs, time, blocking);\n  },\n  exec_show(e, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {\n    this.show(eventType, view, el, display, transition, time, blocking);\n  },\n  exec_hide(e, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {\n    this.hide(eventType, view, el, display, transition, time, blocking);\n  },\n  exec_set_attr(e, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {\n    this.setOrRemoveAttrs(el, [[attr, val]], []);\n  },\n  exec_remove_attr(e, eventType, phxEvent, view, sourceEl, el, { attr }) {\n    this.setOrRemoveAttrs(el, [], [attr]);\n  },\n  ignoreAttrs(el, attrs) {\n    dom_default.putPrivate(el, \"JS:ignore_attrs\", {\n      apply: (fromEl, toEl) => {\n        Array.from(fromEl.attributes).forEach((attr) => {\n          if (attrs.some(\n            (toIgnore) => attr.name == toIgnore || toIgnore.includes(\"*\") && attr.name.match(toIgnore) != null\n          )) {\n            toEl.setAttribute(attr.name, attr.value);\n          }\n        });\n      }\n    });\n  },\n  onBeforeElUpdated(fromEl, toEl) {\n    const ignoreAttrs = dom_default.private(fromEl, \"JS:ignore_attrs\");\n    if (ignoreAttrs) {\n      ignoreAttrs.apply(fromEl, toEl);\n    }\n  },\n  // utils for commands\n  show(eventType, view, el, display, transition, time, blocking) {\n    if (!this.isVisible(el)) {\n      this.toggle(\n        eventType,\n        view,\n        el,\n        display,\n        transition,\n        null,\n        time,\n        blocking\n      );\n    }\n  },\n  hide(eventType, view, el, display, transition, time, blocking) {\n    if (this.isVisible(el)) {\n      this.toggle(\n        eventType,\n        view,\n        el,\n        display,\n        null,\n        transition,\n        time,\n        blocking\n      );\n    }\n  },\n  toggle(eventType, view, el, display, ins, outs, time, blocking) {\n    time = time || default_transition_time;\n    const [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];\n    const [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];\n    if (inClasses.length > 0 || outClasses.length > 0) {\n      if (this.isVisible(el)) {\n        const onStart = () => {\n          this.addOrRemoveClasses(\n            el,\n            outStartClasses,\n            inClasses.concat(inStartClasses).concat(inEndClasses)\n          );\n          window.requestAnimationFrame(() => {\n            this.addOrRemoveClasses(el, outClasses, []);\n            window.requestAnimationFrame(\n              () => this.addOrRemoveClasses(el, outEndClasses, outStartClasses)\n            );\n          });\n        };\n        const onEnd = () => {\n          this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));\n          dom_default.putSticky(\n            el,\n            \"toggle\",\n            (currentEl) => currentEl.style.display = \"none\"\n          );\n          el.dispatchEvent(new Event(\"phx:hide-end\"));\n        };\n        el.dispatchEvent(new Event(\"phx:hide-start\"));\n        if (blocking === false) {\n          onStart();\n          setTimeout(onEnd, time);\n        } else {\n          view.transition(time, onStart, onEnd);\n        }\n      } else {\n        if (eventType === \"remove\") {\n          return;\n        }\n        const onStart = () => {\n          this.addOrRemoveClasses(\n            el,\n            inStartClasses,\n            outClasses.concat(outStartClasses).concat(outEndClasses)\n          );\n          const stickyDisplay = display || this.defaultDisplay(el);\n          window.requestAnimationFrame(() => {\n            this.addOrRemoveClasses(el, inClasses, []);\n            window.requestAnimationFrame(() => {\n              dom_default.putSticky(\n                el,\n                \"toggle\",\n                (currentEl) => currentEl.style.display = stickyDisplay\n              );\n              this.addOrRemoveClasses(el, inEndClasses, inStartClasses);\n            });\n          });\n        };\n        const onEnd = () => {\n          this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));\n          el.dispatchEvent(new Event(\"phx:show-end\"));\n        };\n        el.dispatchEvent(new Event(\"phx:show-start\"));\n        if (blocking === false) {\n          onStart();\n          setTimeout(onEnd, time);\n        } else {\n          view.transition(time, onStart, onEnd);\n        }\n      }\n    } else {\n      if (this.isVisible(el)) {\n        window.requestAnimationFrame(() => {\n          el.dispatchEvent(new Event(\"phx:hide-start\"));\n          dom_default.putSticky(\n            el,\n            \"toggle\",\n            (currentEl) => currentEl.style.display = \"none\"\n          );\n          el.dispatchEvent(new Event(\"phx:hide-end\"));\n        });\n      } else {\n        window.requestAnimationFrame(() => {\n          el.dispatchEvent(new Event(\"phx:show-start\"));\n          const stickyDisplay = display || this.defaultDisplay(el);\n          dom_default.putSticky(\n            el,\n            \"toggle\",\n            (currentEl) => currentEl.style.display = stickyDisplay\n          );\n          el.dispatchEvent(new Event(\"phx:show-end\"));\n        });\n      }\n    }\n  },\n  toggleClasses(el, classes, transition, time, view, blocking) {\n    window.requestAnimationFrame(() => {\n      const [prevAdds, prevRemoves] = dom_default.getSticky(el, \"classes\", [[], []]);\n      const newAdds = classes.filter(\n        (name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name)\n      );\n      const newRemoves = classes.filter(\n        (name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name)\n      );\n      this.addOrRemoveClasses(\n        el,\n        newAdds,\n        newRemoves,\n        transition,\n        time,\n        view,\n        blocking\n      );\n    });\n  },\n  toggleAttr(el, attr, val1, val2) {\n    if (el.hasAttribute(attr)) {\n      if (val2 !== void 0) {\n        if (el.getAttribute(attr) === val1) {\n          this.setOrRemoveAttrs(el, [[attr, val2]], []);\n        } else {\n          this.setOrRemoveAttrs(el, [[attr, val1]], []);\n        }\n      } else {\n        this.setOrRemoveAttrs(el, [], [attr]);\n      }\n    } else {\n      this.setOrRemoveAttrs(el, [[attr, val1]], []);\n    }\n  },\n  addOrRemoveClasses(el, adds, removes, transition, time, view, blocking) {\n    time = time || default_transition_time;\n    const [transitionRun, transitionStart, transitionEnd] = transition || [\n      [],\n      [],\n      []\n    ];\n    if (transitionRun.length > 0) {\n      const onStart = () => {\n        this.addOrRemoveClasses(\n          el,\n          transitionStart,\n          [].concat(transitionRun).concat(transitionEnd)\n        );\n        window.requestAnimationFrame(() => {\n          this.addOrRemoveClasses(el, transitionRun, []);\n          window.requestAnimationFrame(\n            () => this.addOrRemoveClasses(el, transitionEnd, transitionStart)\n          );\n        });\n      };\n      const onDone = () => this.addOrRemoveClasses(\n        el,\n        adds.concat(transitionEnd),\n        removes.concat(transitionRun).concat(transitionStart)\n      );\n      if (blocking === false) {\n        onStart();\n        setTimeout(onDone, time);\n      } else {\n        view.transition(time, onStart, onDone);\n      }\n      return;\n    }\n    window.requestAnimationFrame(() => {\n      const [prevAdds, prevRemoves] = dom_default.getSticky(el, \"classes\", [[], []]);\n      const keepAdds = adds.filter(\n        (name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name)\n      );\n      const keepRemoves = removes.filter(\n        (name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name)\n      );\n      const newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);\n      const newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);\n      dom_default.putSticky(el, \"classes\", (currentEl) => {\n        currentEl.classList.remove(...newRemoves);\n        currentEl.classList.add(...newAdds);\n        return [newAdds, newRemoves];\n      });\n    });\n  },\n  setOrRemoveAttrs(el, sets, removes) {\n    const [prevSets, prevRemoves] = dom_default.getSticky(el, \"attrs\", [[], []]);\n    const alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);\n    const newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);\n    const newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);\n    dom_default.putSticky(el, \"attrs\", (currentEl) => {\n      newRemoves.forEach((attr) => currentEl.removeAttribute(attr));\n      newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));\n      return [newSets, newRemoves];\n    });\n  },\n  hasAllClasses(el, classes) {\n    return classes.every((name) => el.classList.contains(name));\n  },\n  isToggledOut(el, outClasses) {\n    return !this.isVisible(el) || this.hasAllClasses(el, outClasses);\n  },\n  filterToEls(liveSocket, sourceEl, { to }) {\n    const defaultQuery = () => {\n      if (typeof to === \"string\") {\n        return document.querySelectorAll(to);\n      } else if (to.closest) {\n        const toEl = sourceEl.closest(to.closest);\n        return toEl ? [toEl] : [];\n      } else if (to.inner) {\n        return sourceEl.querySelectorAll(to.inner);\n      }\n    };\n    return to ? liveSocket.jsQuerySelectorAll(sourceEl, to, defaultQuery) : [sourceEl];\n  },\n  defaultDisplay(el) {\n    return { tr: \"table-row\", td: \"table-cell\" }[el.tagName.toLowerCase()] || \"block\";\n  },\n  transitionClasses(val) {\n    if (!val) {\n      return null;\n    }\n    let [trans, tStart, tEnd] = Array.isArray(val) ? val : [val.split(\" \"), [], []];\n    trans = Array.isArray(trans) ? trans : trans.split(\" \");\n    tStart = Array.isArray(tStart) ? tStart : tStart.split(\" \");\n    tEnd = Array.isArray(tEnd) ? tEnd : tEnd.split(\" \");\n    return [trans, tStart, tEnd];\n  }\n};\nvar js_default = JS;\n\n// js/phoenix_live_view/js_commands.ts\nvar js_commands_default = (liveSocket, eventType) => {\n  return {\n    exec(el, encodedJS) {\n      liveSocket.execJS(el, encodedJS, eventType);\n    },\n    show(el, opts = {}) {\n      const owner = liveSocket.owner(el);\n      js_default.show(\n        eventType,\n        owner,\n        el,\n        opts.display,\n        js_default.transitionClasses(opts.transition),\n        opts.time,\n        opts.blocking\n      );\n    },\n    hide(el, opts = {}) {\n      const owner = liveSocket.owner(el);\n      js_default.hide(\n        eventType,\n        owner,\n        el,\n        null,\n        js_default.transitionClasses(opts.transition),\n        opts.time,\n        opts.blocking\n      );\n    },\n    toggle(el, opts = {}) {\n      const owner = liveSocket.owner(el);\n      const inTransition = js_default.transitionClasses(opts.in);\n      const outTransition = js_default.transitionClasses(opts.out);\n      js_default.toggle(\n        eventType,\n        owner,\n        el,\n        opts.display,\n        inTransition,\n        outTransition,\n        opts.time,\n        opts.blocking\n      );\n    },\n    addClass(el, names, opts = {}) {\n      const classNames = Array.isArray(names) ? names : names.split(\" \");\n      const owner = liveSocket.owner(el);\n      js_default.addOrRemoveClasses(\n        el,\n        classNames,\n        [],\n        js_default.transitionClasses(opts.transition),\n        opts.time,\n        owner,\n        opts.blocking\n      );\n    },\n    removeClass(el, names, opts = {}) {\n      const classNames = Array.isArray(names) ? names : names.split(\" \");\n      const owner = liveSocket.owner(el);\n      js_default.addOrRemoveClasses(\n        el,\n        [],\n        classNames,\n        js_default.transitionClasses(opts.transition),\n        opts.time,\n        owner,\n        opts.blocking\n      );\n    },\n    toggleClass(el, names, opts = {}) {\n      const classNames = Array.isArray(names) ? names : names.split(\" \");\n      const owner = liveSocket.owner(el);\n      js_default.toggleClasses(\n        el,\n        classNames,\n        js_default.transitionClasses(opts.transition),\n        opts.time,\n        owner,\n        opts.blocking\n      );\n    },\n    transition(el, transition, opts = {}) {\n      const owner = liveSocket.owner(el);\n      js_default.addOrRemoveClasses(\n        el,\n        [],\n        [],\n        js_default.transitionClasses(transition),\n        opts.time,\n        owner,\n        opts.blocking\n      );\n    },\n    setAttribute(el, attr, val) {\n      js_default.setOrRemoveAttrs(el, [[attr, val]], []);\n    },\n    removeAttribute(el, attr) {\n      js_default.setOrRemoveAttrs(el, [], [attr]);\n    },\n    toggleAttribute(el, attr, val1, val2) {\n      js_default.toggleAttr(el, attr, val1, val2);\n    },\n    push(el, type, opts = {}) {\n      liveSocket.withinOwners(el, (view) => {\n        const data = opts.value || {};\n        delete opts.value;\n        let e = new CustomEvent(\"phx:exec\", { detail: { sourceElement: el } });\n        js_default.exec(e, eventType, type, view, el, [\"push\", { data, ...opts }]);\n      });\n    },\n    navigate(href, opts = {}) {\n      const customEvent = new CustomEvent(\"phx:exec\");\n      liveSocket.historyRedirect(\n        customEvent,\n        href,\n        opts.replace ? \"replace\" : \"push\",\n        null,\n        null\n      );\n    },\n    patch(href, opts = {}) {\n      const customEvent = new CustomEvent(\"phx:exec\");\n      liveSocket.pushHistoryPatch(\n        customEvent,\n        href,\n        opts.replace ? \"replace\" : \"push\",\n        null\n      );\n    },\n    ignoreAttributes(el, attrs) {\n      js_default.ignoreAttrs(el, Array.isArray(attrs) ? attrs : [attrs]);\n    }\n  };\n};\n\n// js/phoenix_live_view/view_hook.ts\nvar HOOK_ID = \"hookId\";\nvar viewHookID = 1;\nvar ViewHook = class _ViewHook {\n  static makeID() {\n    return viewHookID++;\n  }\n  static elementID(el) {\n    return dom_default.private(el, HOOK_ID);\n  }\n  constructor(view, el, callbacks) {\n    this.el = el;\n    this.__attachView(view);\n    this.__listeners = /* @__PURE__ */ new Set();\n    this.__isDisconnected = false;\n    dom_default.putPrivate(this.el, HOOK_ID, _ViewHook.makeID());\n    if (callbacks) {\n      const protectedProps = /* @__PURE__ */ new Set([\n        \"el\",\n        \"liveSocket\",\n        \"__view\",\n        \"__listeners\",\n        \"__isDisconnected\",\n        \"constructor\",\n        // Standard object properties\n        // Core ViewHook API methods\n        \"js\",\n        \"pushEvent\",\n        \"pushEventTo\",\n        \"handleEvent\",\n        \"removeHandleEvent\",\n        \"upload\",\n        \"uploadTo\",\n        // Internal lifecycle callers\n        \"__mounted\",\n        \"__updated\",\n        \"__beforeUpdate\",\n        \"__destroyed\",\n        \"__reconnected\",\n        \"__disconnected\",\n        \"__cleanup__\"\n      ]);\n      for (const key in callbacks) {\n        if (Object.prototype.hasOwnProperty.call(callbacks, key)) {\n          this[key] = callbacks[key];\n          if (protectedProps.has(key)) {\n            console.warn(\n              `Hook object for element #${el.id} overwrites core property '${key}'!`\n            );\n          }\n        }\n      }\n      const lifecycleMethods = [\n        \"mounted\",\n        \"beforeUpdate\",\n        \"updated\",\n        \"destroyed\",\n        \"disconnected\",\n        \"reconnected\"\n      ];\n      lifecycleMethods.forEach((methodName) => {\n        if (callbacks[methodName] && typeof callbacks[methodName] === \"function\") {\n          this[methodName] = callbacks[methodName];\n        }\n      });\n    }\n  }\n  /** @internal */\n  __attachView(view) {\n    if (view) {\n      this.__view = () => view;\n      this.liveSocket = view.liveSocket;\n    } else {\n      this.__view = () => {\n        throw new Error(\n          `hook not yet attached to a live view: ${this.el.outerHTML}`\n        );\n      };\n      this.liveSocket = null;\n    }\n  }\n  // Default lifecycle methods\n  mounted() {\n  }\n  beforeUpdate() {\n  }\n  updated() {\n  }\n  destroyed() {\n  }\n  disconnected() {\n  }\n  reconnected() {\n  }\n  // Internal lifecycle callers - called by the View\n  /** @internal */\n  __mounted() {\n    this.mounted();\n  }\n  /** @internal */\n  __updated() {\n    this.updated();\n  }\n  /** @internal */\n  __beforeUpdate() {\n    this.beforeUpdate();\n  }\n  /** @internal */\n  __destroyed() {\n    this.destroyed();\n    dom_default.deletePrivate(this.el, HOOK_ID);\n  }\n  /** @internal */\n  __reconnected() {\n    if (this.__isDisconnected) {\n      this.__isDisconnected = false;\n      this.reconnected();\n    }\n  }\n  /** @internal */\n  __disconnected() {\n    this.__isDisconnected = true;\n    this.disconnected();\n  }\n  js() {\n    return {\n      ...js_commands_default(this.__view().liveSocket, \"hook\"),\n      exec: (encodedJS) => {\n        this.__view().liveSocket.execJS(this.el, encodedJS, \"hook\");\n      }\n    };\n  }\n  pushEvent(event, payload, onReply) {\n    const promise = this.__view().pushHookEvent(\n      this.el,\n      null,\n      event,\n      payload || {}\n    );\n    if (onReply === void 0) {\n      return promise.then(({ reply }) => reply);\n    }\n    promise.then(({ reply, ref }) => onReply(reply, ref)).catch(() => {\n    });\n    return;\n  }\n  pushEventTo(selectorOrTarget, event, payload, onReply) {\n    if (onReply === void 0) {\n      const targetPair = [];\n      this.__view().withinTargets(selectorOrTarget, (view, targetCtx) => {\n        targetPair.push({ view, targetCtx });\n      });\n      const promises = targetPair.map(({ view, targetCtx }) => {\n        return view.pushHookEvent(this.el, targetCtx, event, payload || {});\n      });\n      return Promise.allSettled(promises);\n    }\n    this.__view().withinTargets(selectorOrTarget, (view, targetCtx) => {\n      view.pushHookEvent(this.el, targetCtx, event, payload || {}).then(({ reply, ref }) => onReply(reply, ref)).catch(() => {\n      });\n    });\n    return;\n  }\n  handleEvent(event, callback) {\n    const callbackRef = {\n      event,\n      callback: (customEvent) => callback(customEvent.detail)\n    };\n    window.addEventListener(\n      `phx:${event}`,\n      callbackRef.callback\n    );\n    this.__listeners.add(callbackRef);\n    return callbackRef;\n  }\n  removeHandleEvent(ref) {\n    window.removeEventListener(\n      `phx:${ref.event}`,\n      ref.callback\n    );\n    this.__listeners.delete(ref);\n  }\n  upload(name, files) {\n    return this.__view().dispatchUploads(null, name, files);\n  }\n  uploadTo(selectorOrTarget, name, files) {\n    return this.__view().withinTargets(selectorOrTarget, (view, targetCtx) => {\n      view.dispatchUploads(targetCtx, name, files);\n    });\n  }\n  /** @internal */\n  __cleanup__() {\n    this.__listeners.forEach(\n      (callbackRef) => this.removeHandleEvent(callbackRef)\n    );\n  }\n};\n\n// js/phoenix_live_view/view.js\nvar prependFormDataKey = (key, prefix) => {\n  const isArray = key.endsWith(\"[]\");\n  let baseKey = isArray ? key.slice(0, -2) : key;\n  baseKey = baseKey.replace(/([^\\[\\]]+)(\\]?$)/, `${prefix}$1$2`);\n  if (isArray) {\n    baseKey += \"[]\";\n  }\n  return baseKey;\n};\nvar serializeForm = (form, opts, onlyNames = []) => {\n  const { submitter } = opts;\n  let injectedElement;\n  if (submitter && submitter.name) {\n    const input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    const formId = submitter.getAttribute(\"form\");\n    if (formId) {\n      input.setAttribute(\"form\", formId);\n    }\n    input.name = submitter.name;\n    input.value = submitter.value;\n    submitter.parentElement.insertBefore(input, submitter);\n    injectedElement = input;\n  }\n  const formData = new FormData(form);\n  const toRemove = [];\n  formData.forEach((val, key, _index) => {\n    if (val instanceof File) {\n      toRemove.push(key);\n    }\n  });\n  toRemove.forEach((key) => formData.delete(key));\n  const params = new URLSearchParams();\n  const { inputsUnused, onlyHiddenInputs } = Array.from(form.elements).reduce(\n    (acc, input) => {\n      const { inputsUnused: inputsUnused2, onlyHiddenInputs: onlyHiddenInputs2 } = acc;\n      const key = input.name;\n      if (!key) {\n        return acc;\n      }\n      if (inputsUnused2[key] === void 0) {\n        inputsUnused2[key] = true;\n      }\n      if (onlyHiddenInputs2[key] === void 0) {\n        onlyHiddenInputs2[key] = true;\n      }\n      const isUsed = dom_default.private(input, PHX_HAS_FOCUSED) || dom_default.private(input, PHX_HAS_SUBMITTED);\n      const isHidden = input.type === \"hidden\";\n      inputsUnused2[key] = inputsUnused2[key] && !isUsed;\n      onlyHiddenInputs2[key] = onlyHiddenInputs2[key] && isHidden;\n      return acc;\n    },\n    { inputsUnused: {}, onlyHiddenInputs: {} }\n  );\n  for (const [key, val] of formData.entries()) {\n    if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {\n      const isUnused = inputsUnused[key];\n      const hidden = onlyHiddenInputs[key];\n      if (isUnused && !(submitter && submitter.name == key) && !hidden) {\n        params.append(prependFormDataKey(key, \"_unused_\"), \"\");\n      }\n      if (typeof val === \"string\") {\n        params.append(key, val);\n      }\n    }\n  }\n  if (submitter && injectedElement) {\n    submitter.parentElement.removeChild(injectedElement);\n  }\n  return params.toString();\n};\nvar View = class _View {\n  static closestView(el) {\n    const liveViewEl = el.closest(PHX_VIEW_SELECTOR);\n    return liveViewEl ? dom_default.private(liveViewEl, \"view\") : null;\n  }\n  constructor(el, liveSocket, parentView, flash, liveReferer) {\n    this.isDead = false;\n    this.liveSocket = liveSocket;\n    this.flash = flash;\n    this.parent = parentView;\n    this.root = parentView ? parentView.root : this;\n    this.el = el;\n    const boundView = dom_default.private(this.el, \"view\");\n    if (boundView !== void 0 && boundView.isDead !== true) {\n      logError(\n        `The DOM element for this view has already been bound to a view.\n\n        An element can only ever be associated with a single view!\n        Please ensure that you are not trying to initialize multiple LiveSockets on the same page.\n        This could happen if you're accidentally trying to render your root layout more than once.\n        Ensure that the template set on the LiveView is different than the root layout.\n      `,\n        { view: boundView }\n      );\n      throw new Error(\"Cannot bind multiple views to the same DOM element.\");\n    }\n    dom_default.putPrivate(this.el, \"view\", this);\n    this.id = this.el.id;\n    this.ref = 0;\n    this.lastAckRef = null;\n    this.childJoins = 0;\n    this.loaderTimer = null;\n    this.disconnectedTimer = null;\n    this.pendingDiffs = [];\n    this.pendingForms = /* @__PURE__ */ new Set();\n    this.redirect = false;\n    this.href = null;\n    this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\n    this.joinAttempts = 0;\n    this.joinPending = true;\n    this.destroyed = false;\n    this.joinCallback = function(onDone) {\n      onDone && onDone();\n    };\n    this.stopCallback = function() {\n    };\n    this.pendingJoinOps = this.parent ? null : [];\n    this.viewHooks = {};\n    this.formSubmits = [];\n    this.children = this.parent ? null : {};\n    this.root.children[this.id] = {};\n    this.formsForRecovery = {};\n    this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\n      const url = this.href && this.expandURL(this.href);\n      return {\n        redirect: this.redirect ? url : void 0,\n        url: this.redirect ? void 0 : url || void 0,\n        params: this.connectParams(liveReferer),\n        session: this.getSession(),\n        static: this.getStatic(),\n        flash: this.flash,\n        sticky: this.el.hasAttribute(PHX_STICKY)\n      };\n    });\n    this.portalElementIds = /* @__PURE__ */ new Set();\n  }\n  setHref(href) {\n    this.href = href;\n  }\n  setRedirect(href) {\n    this.redirect = true;\n    this.href = href;\n  }\n  isMain() {\n    return this.el.hasAttribute(PHX_MAIN);\n  }\n  connectParams(liveReferer) {\n    const params = this.liveSocket.params(this.el);\n    const manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === \"string\");\n    if (manifest.length > 0) {\n      params[\"_track_static\"] = manifest;\n    }\n    params[\"_mounts\"] = this.joinCount;\n    params[\"_mount_attempts\"] = this.joinAttempts;\n    params[\"_live_referer\"] = liveReferer;\n    this.joinAttempts++;\n    return params;\n  }\n  isConnected() {\n    return this.channel.canPush();\n  }\n  getSession() {\n    return this.el.getAttribute(PHX_SESSION);\n  }\n  getStatic() {\n    const val = this.el.getAttribute(PHX_STATIC);\n    return val === \"\" ? null : val;\n  }\n  destroy(callback = function() {\n  }) {\n    this.destroyAllChildren();\n    this.destroyPortalElements();\n    this.destroyed = true;\n    dom_default.deletePrivate(this.el, \"view\");\n    delete this.root.children[this.id];\n    if (this.parent) {\n      delete this.root.children[this.parent.id][this.id];\n    }\n    clearTimeout(this.loaderTimer);\n    const onFinished = () => {\n      callback();\n      for (const id in this.viewHooks) {\n        this.destroyHook(this.viewHooks[id]);\n      }\n    };\n    dom_default.markPhxChildDestroyed(this.el);\n    this.log(\"destroyed\", () => [\"the child has been removed from the parent\"]);\n    this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\n  }\n  setContainerClasses(...classes) {\n    this.el.classList.remove(\n      PHX_CONNECTED_CLASS,\n      PHX_LOADING_CLASS,\n      PHX_ERROR_CLASS,\n      PHX_CLIENT_ERROR_CLASS,\n      PHX_SERVER_ERROR_CLASS\n    );\n    this.el.classList.add(...classes);\n  }\n  showLoader(timeout) {\n    clearTimeout(this.loaderTimer);\n    if (timeout) {\n      this.loaderTimer = setTimeout(() => this.showLoader(), timeout);\n    } else {\n      for (const id in this.viewHooks) {\n        this.viewHooks[id].__disconnected();\n      }\n      this.setContainerClasses(PHX_LOADING_CLASS);\n    }\n  }\n  execAll(binding) {\n    dom_default.all(\n      this.el,\n      `[${binding}]`,\n      (el) => this.liveSocket.execJS(el, el.getAttribute(binding))\n    );\n  }\n  hideLoader() {\n    clearTimeout(this.loaderTimer);\n    clearTimeout(this.disconnectedTimer);\n    this.setContainerClasses(PHX_CONNECTED_CLASS);\n    this.execAll(this.binding(\"connected\"));\n  }\n  triggerReconnected() {\n    for (const id in this.viewHooks) {\n      this.viewHooks[id].__reconnected();\n    }\n  }\n  log(kind, msgCallback) {\n    this.liveSocket.log(this, kind, msgCallback);\n  }\n  transition(time, onStart, onDone = function() {\n  }) {\n    this.liveSocket.transition(time, onStart, onDone);\n  }\n  // calls the callback with the view and target element for the given phxTarget\n  // targets can be:\n  //  * an element itself, then it is simply passed to liveSocket.owner;\n  //  * a CID (Component ID), then we first search the component's element in the DOM\n  //  * a selector, then we search the selector in the DOM and call the callback\n  //    for each element found with the corresponding owner view\n  withinTargets(phxTarget, callback, dom = document) {\n    if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {\n      return this.liveSocket.owner(\n        phxTarget,\n        (view) => callback(view, phxTarget)\n      );\n    }\n    if (isCid(phxTarget)) {\n      const targets = dom_default.findComponentNodeList(this.id, phxTarget, dom);\n      if (targets.length === 0) {\n        logError(`no component found matching phx-target of ${phxTarget}`);\n      } else {\n        callback(this, parseInt(phxTarget));\n      }\n    } else {\n      const targets = Array.from(dom.querySelectorAll(phxTarget));\n      if (targets.length === 0) {\n        logError(\n          `nothing found matching the phx-target selector \"${phxTarget}\"`\n        );\n      }\n      targets.forEach(\n        (target) => this.liveSocket.owner(target, (view) => callback(view, target))\n      );\n    }\n  }\n  applyDiff(type, rawDiff, callback) {\n    this.log(type, () => [\"\", clone(rawDiff)]);\n    const { diff, reply, events, title } = Rendered.extract(rawDiff);\n    callback({ diff, reply, events });\n    if (typeof title === \"string\" || type == \"mount\") {\n      window.requestAnimationFrame(() => dom_default.putTitle(title));\n    }\n  }\n  onJoin(resp) {\n    const { rendered, container, liveview_version, pid } = resp;\n    if (container) {\n      const [tag, attrs] = container;\n      this.el = dom_default.replaceRootContainer(this.el, tag, attrs);\n    }\n    this.childJoins = 0;\n    this.joinPending = true;\n    this.flash = null;\n    if (this.root === this) {\n      this.formsForRecovery = this.getFormsForRecovery();\n    }\n    if (this.isMain() && window.history.state === null) {\n      browser_default.pushState(\"replace\", {\n        type: \"patch\",\n        id: this.id,\n        position: this.liveSocket.currentHistoryPosition\n      });\n    }\n    if (liveview_version !== this.liveSocket.version()) {\n      console.error(\n        `LiveView asset version mismatch. JavaScript version ${this.liveSocket.version()} vs. server ${liveview_version}. To avoid issues, please ensure that your assets use the same version as the server.`\n      );\n    }\n    if (pid) {\n      this.el.setAttribute(PHX_LV_PID, pid);\n    }\n    browser_default.dropLocal(\n      this.liveSocket.localStorage,\n      window.location.pathname,\n      CONSECUTIVE_RELOADS\n    );\n    this.applyDiff(\"mount\", rendered, ({ diff, events }) => {\n      this.rendered = new Rendered(this.id, diff);\n      const [html, streams] = this.renderContainer(null, \"join\");\n      this.dropPendingRefs();\n      this.joinCount++;\n      this.joinAttempts = 0;\n      this.maybeRecoverForms(html, () => {\n        this.onJoinComplete(resp, html, streams, events);\n      });\n    });\n  }\n  dropPendingRefs() {\n    dom_default.all(document, `[${PHX_REF_SRC}=\"${this.refSrc()}\"]`, (el) => {\n      el.removeAttribute(PHX_REF_LOADING);\n      el.removeAttribute(PHX_REF_SRC);\n      el.removeAttribute(PHX_REF_LOCK);\n    });\n  }\n  onJoinComplete({ live_patch }, html, streams, events) {\n    if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {\n      return this.applyJoinPatch(live_patch, html, streams, events);\n    }\n    const newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter(\n      (toEl) => {\n        const fromEl = toEl.id && this.el.querySelector(`[id=\"${toEl.id}\"]`);\n        const phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\n        if (phxStatic) {\n          toEl.setAttribute(PHX_STATIC, phxStatic);\n        }\n        if (fromEl) {\n          fromEl.setAttribute(PHX_ROOT_ID, this.root.id);\n        }\n        return this.joinChild(toEl);\n      }\n    );\n    if (newChildren.length === 0) {\n      if (this.parent) {\n        this.root.pendingJoinOps.push([\n          this,\n          () => this.applyJoinPatch(live_patch, html, streams, events)\n        ]);\n        this.parent.ackJoin(this);\n      } else {\n        this.onAllChildJoinsComplete();\n        this.applyJoinPatch(live_patch, html, streams, events);\n      }\n    } else {\n      this.root.pendingJoinOps.push([\n        this,\n        () => this.applyJoinPatch(live_patch, html, streams, events)\n      ]);\n    }\n  }\n  attachTrueDocEl() {\n    this.el = dom_default.byId(this.id);\n    this.el.setAttribute(PHX_ROOT_ID, this.root.id);\n  }\n  // this is invoked for dead and live views, so we must filter by\n  // by owner to ensure we aren't duplicating hooks across disconnect\n  // and connected states. This also handles cases where hooks exist\n  // in a root layout with a LV in the body\n  execNewMounted(parent = document) {\n    let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);\n    let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);\n    this.all(\n      parent,\n      `[${phxViewportTop}], [${phxViewportBottom}]`,\n      (hookEl) => {\n        dom_default.maintainPrivateHooks(\n          hookEl,\n          hookEl,\n          phxViewportTop,\n          phxViewportBottom\n        );\n        this.maybeAddNewHook(hookEl);\n      }\n    );\n    this.all(\n      parent,\n      `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`,\n      (hookEl) => {\n        this.maybeAddNewHook(hookEl);\n      }\n    );\n    this.all(parent, `[${this.binding(PHX_MOUNTED)}]`, (el) => {\n      this.maybeMounted(el);\n    });\n  }\n  all(parent, selector, callback) {\n    dom_default.all(parent, selector, (el) => {\n      if (this.ownsElement(el)) {\n        callback(el);\n      }\n    });\n  }\n  applyJoinPatch(live_patch, html, streams, events) {\n    this.attachTrueDocEl();\n    const patch = new DOMPatch(this, this.el, this.id, html, streams, null);\n    patch.markPrunableContentForRemoval();\n    this.performPatch(patch, false, true);\n    this.joinNewChildren();\n    this.execNewMounted();\n    this.joinPending = false;\n    this.liveSocket.dispatchEvents(events);\n    this.applyPendingUpdates();\n    if (live_patch) {\n      const { kind, to } = live_patch;\n      this.liveSocket.historyPatch(to, kind);\n    }\n    this.hideLoader();\n    if (this.joinCount > 1) {\n      this.triggerReconnected();\n    }\n    this.stopCallback();\n  }\n  triggerBeforeUpdateHook(fromEl, toEl) {\n    this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\n    const hook = this.getHook(fromEl);\n    const isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));\n    if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {\n      hook.__beforeUpdate();\n      return hook;\n    }\n  }\n  maybeMounted(el) {\n    const phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));\n    const hasBeenInvoked = phxMounted && dom_default.private(el, \"mounted\");\n    if (phxMounted && !hasBeenInvoked) {\n      this.liveSocket.execJS(el, phxMounted);\n      dom_default.putPrivate(el, \"mounted\", true);\n    }\n  }\n  maybeAddNewHook(el) {\n    const newHook = this.addHook(el);\n    if (newHook) {\n      newHook.__mounted();\n    }\n  }\n  performPatch(patch, pruneCids, isJoinPatch = false) {\n    const removedEls = [];\n    let phxChildrenAdded = false;\n    const updatedHookIds = /* @__PURE__ */ new Set();\n    this.liveSocket.triggerDOM(\"onPatchStart\", [patch.targetContainer]);\n    patch.after(\"added\", (el) => {\n      this.liveSocket.triggerDOM(\"onNodeAdded\", [el]);\n      const phxViewportTop = this.binding(PHX_VIEWPORT_TOP);\n      const phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);\n      dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);\n      this.maybeAddNewHook(el);\n      if (el.getAttribute) {\n        this.maybeMounted(el);\n      }\n    });\n    patch.after(\"phxChildAdded\", (el) => {\n      if (dom_default.isPhxSticky(el)) {\n        this.liveSocket.joinRootViews();\n      } else {\n        phxChildrenAdded = true;\n      }\n    });\n    patch.before(\"updated\", (fromEl, toEl) => {\n      const hook = this.triggerBeforeUpdateHook(fromEl, toEl);\n      if (hook) {\n        updatedHookIds.add(fromEl.id);\n      }\n      js_default.onBeforeElUpdated(fromEl, toEl);\n    });\n    patch.after(\"updated\", (el) => {\n      if (updatedHookIds.has(el.id)) {\n        this.getHook(el).__updated();\n      }\n    });\n    patch.after(\"discarded\", (el) => {\n      if (el.nodeType === Node.ELEMENT_NODE) {\n        removedEls.push(el);\n      }\n    });\n    patch.after(\n      \"transitionsDiscarded\",\n      (els) => this.afterElementsRemoved(els, pruneCids)\n    );\n    patch.perform(isJoinPatch);\n    this.afterElementsRemoved(removedEls, pruneCids);\n    this.liveSocket.triggerDOM(\"onPatchEnd\", [patch.targetContainer]);\n    return phxChildrenAdded;\n  }\n  afterElementsRemoved(elements, pruneCids) {\n    const destroyedCIDs = [];\n    elements.forEach((parent) => {\n      const components = dom_default.all(\n        parent,\n        `[${PHX_VIEW_REF}=\"${this.id}\"][${PHX_COMPONENT}]`\n      );\n      const hooks = dom_default.all(\n        parent,\n        `[${this.binding(PHX_HOOK)}], [data-phx-hook]`\n      );\n      components.concat(parent).forEach((el) => {\n        const cid = this.componentID(el);\n        if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1 && el.getAttribute(PHX_VIEW_REF) === this.id) {\n          destroyedCIDs.push(cid);\n        }\n      });\n      hooks.concat(parent).forEach((hookEl) => {\n        const hook = this.getHook(hookEl);\n        hook && this.destroyHook(hook);\n      });\n    });\n    if (pruneCids) {\n      this.maybePushComponentsDestroyed(destroyedCIDs);\n    }\n  }\n  joinNewChildren() {\n    dom_default.findPhxChildren(document, this.id).forEach((el) => this.joinChild(el));\n  }\n  maybeRecoverForms(html, callback) {\n    const phxChange = this.binding(\"change\");\n    const oldForms = this.root.formsForRecovery;\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    const rootEl = template.content.firstElementChild;\n    rootEl.id = this.id;\n    rootEl.setAttribute(PHX_ROOT_ID, this.root.id);\n    rootEl.setAttribute(PHX_SESSION, this.getSession());\n    rootEl.setAttribute(PHX_STATIC, this.getStatic());\n    rootEl.setAttribute(PHX_PARENT_ID, this.parent ? this.parent.id : null);\n    const formsToRecover = (\n      // we go over all forms in the new DOM; because this is only the HTML for the current\n      // view, we can be sure that all forms are owned by this view:\n      dom_default.all(template.content, \"form\").filter((newForm) => newForm.id && oldForms[newForm.id]).filter((newForm) => !this.pendingForms.has(newForm.id)).filter(\n        (newForm) => oldForms[newForm.id].getAttribute(phxChange) === newForm.getAttribute(phxChange)\n      ).map((newForm) => {\n        return [oldForms[newForm.id], newForm];\n      })\n    );\n    if (formsToRecover.length === 0) {\n      return callback();\n    }\n    formsToRecover.forEach(([oldForm, newForm], i) => {\n      this.pendingForms.add(newForm.id);\n      this.pushFormRecovery(\n        oldForm,\n        newForm,\n        template.content.firstElementChild,\n        () => {\n          this.pendingForms.delete(newForm.id);\n          if (i === formsToRecover.length - 1) {\n            callback();\n          }\n        }\n      );\n    });\n  }\n  getChildById(id) {\n    return this.root.children[this.id][id];\n  }\n  getDescendentByEl(el) {\n    if (el.id === this.id) {\n      return this;\n    } else {\n      return this.children[el.getAttribute(PHX_PARENT_ID)]?.[el.id];\n    }\n  }\n  destroyDescendent(id) {\n    for (const parentId in this.root.children) {\n      for (const childId in this.root.children[parentId]) {\n        if (childId === id) {\n          return this.root.children[parentId][childId].destroy();\n        }\n      }\n    }\n  }\n  joinChild(el) {\n    const child = this.getChildById(el.id);\n    if (!child) {\n      const view = new _View(el, this.liveSocket, this);\n      this.root.children[this.id][view.id] = view;\n      view.join();\n      this.childJoins++;\n      return true;\n    }\n  }\n  isJoinPending() {\n    return this.joinPending;\n  }\n  ackJoin(_child) {\n    this.childJoins--;\n    if (this.childJoins === 0) {\n      if (this.parent) {\n        this.parent.ackJoin(this);\n      } else {\n        this.onAllChildJoinsComplete();\n      }\n    }\n  }\n  onAllChildJoinsComplete() {\n    this.pendingForms.clear();\n    this.formsForRecovery = {};\n    this.joinCallback(() => {\n      this.pendingJoinOps.forEach(([view, op]) => {\n        if (!view.isDestroyed()) {\n          op();\n        }\n      });\n      this.pendingJoinOps = [];\n    });\n  }\n  update(diff, events, isPending = false) {\n    if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {\n      if (!isPending) {\n        this.pendingDiffs.push({ diff, events });\n      }\n      return false;\n    }\n    this.rendered.mergeDiff(diff);\n    let phxChildrenAdded = false;\n    if (this.rendered.isComponentOnlyDiff(diff)) {\n      this.liveSocket.time(\"component patch complete\", () => {\n        const parentCids = dom_default.findExistingParentCIDs(\n          this.id,\n          this.rendered.componentCIDs(diff)\n        );\n        parentCids.forEach((parentCID) => {\n          if (this.componentPatch(\n            this.rendered.getComponent(diff, parentCID),\n            parentCID\n          )) {\n            phxChildrenAdded = true;\n          }\n        });\n      });\n    } else if (!isEmpty(diff)) {\n      this.liveSocket.time(\"full patch complete\", () => {\n        const [html, streams] = this.renderContainer(diff, \"update\");\n        const patch = new DOMPatch(this, this.el, this.id, html, streams, null);\n        phxChildrenAdded = this.performPatch(patch, true);\n      });\n    }\n    this.liveSocket.dispatchEvents(events);\n    if (phxChildrenAdded) {\n      this.joinNewChildren();\n    }\n    return true;\n  }\n  renderContainer(diff, kind) {\n    return this.liveSocket.time(`toString diff (${kind})`, () => {\n      const tag = this.el.tagName;\n      const cids = diff ? this.rendered.componentCIDs(diff) : null;\n      const { buffer: html, streams } = this.rendered.toString(cids);\n      return [`<${tag}>${html}</${tag}>`, streams];\n    });\n  }\n  componentPatch(diff, cid) {\n    if (isEmpty(diff))\n      return false;\n    const { buffer: html, streams } = this.rendered.componentToString(cid);\n    const patch = new DOMPatch(this, this.el, this.id, html, streams, cid);\n    const childrenAdded = this.performPatch(patch, true);\n    return childrenAdded;\n  }\n  getHook(el) {\n    return this.viewHooks[ViewHook.elementID(el)];\n  }\n  addHook(el) {\n    const hookElId = ViewHook.elementID(el);\n    if (el.getAttribute && !this.ownsElement(el)) {\n      return;\n    }\n    if (hookElId && !this.viewHooks[hookElId]) {\n      const hook = dom_default.getCustomElHook(el) || logError(`no hook found for custom element: ${el.id}`);\n      this.viewHooks[hookElId] = hook;\n      hook.__attachView(this);\n      return hook;\n    } else if (hookElId || !el.getAttribute) {\n      return;\n    } else {\n      const hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));\n      if (!hookName) {\n        return;\n      }\n      const hookDefinition = this.liveSocket.getHookDefinition(hookName);\n      if (hookDefinition) {\n        if (!el.id) {\n          logError(\n            `no DOM ID for hook \"${hookName}\". Hooks require a unique ID on each element.`,\n            el\n          );\n          return;\n        }\n        let hookInstance;\n        try {\n          if (typeof hookDefinition === \"function\" && hookDefinition.prototype instanceof ViewHook) {\n            hookInstance = new hookDefinition(this, el);\n          } else if (typeof hookDefinition === \"object\" && hookDefinition !== null) {\n            hookInstance = new ViewHook(this, el, hookDefinition);\n          } else {\n            logError(\n              `Invalid hook definition for \"${hookName}\". Expected a class extending ViewHook or an object definition.`,\n              el\n            );\n            return;\n          }\n        } catch (e) {\n          const errorMessage = e instanceof Error ? e.message : String(e);\n          logError(`Failed to create hook \"${hookName}\": ${errorMessage}`, el);\n          return;\n        }\n        this.viewHooks[ViewHook.elementID(hookInstance.el)] = hookInstance;\n        return hookInstance;\n      } else if (hookName !== null) {\n        logError(`unknown hook found for \"${hookName}\"`, el);\n      }\n    }\n  }\n  destroyHook(hook) {\n    const hookId = ViewHook.elementID(hook.el);\n    hook.__destroyed();\n    hook.__cleanup__();\n    delete this.viewHooks[hookId];\n  }\n  applyPendingUpdates() {\n    this.pendingDiffs = this.pendingDiffs.filter(\n      ({ diff, events }) => !this.update(diff, events, true)\n    );\n    this.eachChild((child) => child.applyPendingUpdates());\n  }\n  eachChild(callback) {\n    const children = this.root.children[this.id] || {};\n    for (const id in children) {\n      callback(this.getChildById(id));\n    }\n  }\n  onChannel(event, cb) {\n    this.liveSocket.onChannel(this.channel, event, (resp) => {\n      if (this.isJoinPending()) {\n        this.root.pendingJoinOps.push([this, () => cb(resp)]);\n      } else {\n        this.liveSocket.requestDOMUpdate(() => cb(resp));\n      }\n    });\n  }\n  bindChannel() {\n    this.liveSocket.onChannel(this.channel, \"diff\", (rawDiff) => {\n      this.liveSocket.requestDOMUpdate(() => {\n        this.applyDiff(\n          \"update\",\n          rawDiff,\n          ({ diff, events }) => this.update(diff, events)\n        );\n      });\n    });\n    this.onChannel(\n      \"redirect\",\n      ({ to, flash }) => this.onRedirect({ to, flash })\n    );\n    this.onChannel(\"live_patch\", (redir) => this.onLivePatch(redir));\n    this.onChannel(\"live_redirect\", (redir) => this.onLiveRedirect(redir));\n    this.channel.onError((reason) => this.onError(reason));\n    this.channel.onClose((reason) => this.onClose(reason));\n  }\n  destroyAllChildren() {\n    this.eachChild((child) => child.destroy());\n  }\n  onLiveRedirect(redir) {\n    const { to, kind, flash } = redir;\n    const url = this.expandURL(to);\n    const e = new CustomEvent(\"phx:server-navigate\", {\n      detail: { to, kind, flash }\n    });\n    this.liveSocket.historyRedirect(e, url, kind, flash);\n  }\n  onLivePatch(redir) {\n    const { to, kind } = redir;\n    this.href = this.expandURL(to);\n    this.liveSocket.historyPatch(to, kind);\n  }\n  expandURL(to) {\n    return to.startsWith(\"/\") ? `${window.location.protocol}//${window.location.host}${to}` : to;\n  }\n  /**\n   * @param {{to: string, flash?: string, reloadToken?: string}} redirect\n   */\n  onRedirect({ to, flash, reloadToken }) {\n    this.liveSocket.redirect(to, flash, reloadToken);\n  }\n  isDestroyed() {\n    return this.destroyed;\n  }\n  joinDead() {\n    this.isDead = true;\n  }\n  joinPush() {\n    this.joinPush = this.joinPush || this.channel.join();\n    return this.joinPush;\n  }\n  join(callback) {\n    this.showLoader(this.liveSocket.loaderTimeout);\n    this.bindChannel();\n    if (this.isMain()) {\n      this.stopCallback = this.liveSocket.withPageLoading({\n        to: this.href,\n        kind: \"initial\"\n      });\n    }\n    this.joinCallback = (onDone) => {\n      onDone = onDone || function() {\n      };\n      callback ? callback(this.joinCount, onDone) : onDone();\n    };\n    this.wrapPush(() => this.channel.join(), {\n      ok: (resp) => this.liveSocket.requestDOMUpdate(() => this.onJoin(resp)),\n      error: (error) => this.onJoinError(error),\n      timeout: () => this.onJoinError({ reason: \"timeout\" })\n    });\n  }\n  onJoinError(resp) {\n    if (resp.reason === \"reload\") {\n      this.log(\"error\", () => [\n        `failed mount with ${resp.status}. Falling back to page reload`,\n        resp\n      ]);\n      this.onRedirect({ to: this.root.href, reloadToken: resp.token });\n      return;\n    } else if (resp.reason === \"unauthorized\" || resp.reason === \"stale\") {\n      this.log(\"error\", () => [\n        \"unauthorized live_redirect. Falling back to page request\",\n        resp\n      ]);\n      this.onRedirect({ to: this.root.href, flash: this.flash });\n      return;\n    }\n    if (resp.redirect || resp.live_redirect) {\n      this.joinPending = false;\n      this.channel.leave();\n    }\n    if (resp.redirect) {\n      return this.onRedirect(resp.redirect);\n    }\n    if (resp.live_redirect) {\n      return this.onLiveRedirect(resp.live_redirect);\n    }\n    this.log(\"error\", () => [\"unable to join\", resp]);\n    if (this.isMain()) {\n      this.displayError([\n        PHX_LOADING_CLASS,\n        PHX_ERROR_CLASS,\n        PHX_SERVER_ERROR_CLASS\n      ]);\n      if (this.liveSocket.isConnected()) {\n        this.liveSocket.reloadWithJitter(this);\n      }\n    } else {\n      if (this.joinAttempts >= MAX_CHILD_JOIN_ATTEMPTS) {\n        this.root.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_SERVER_ERROR_CLASS\n        ]);\n        this.log(\"error\", () => [\n          `giving up trying to mount after ${MAX_CHILD_JOIN_ATTEMPTS} tries`,\n          resp\n        ]);\n        this.destroy();\n      }\n      const trueChildEl = dom_default.byId(this.el.id);\n      if (trueChildEl) {\n        dom_default.mergeAttrs(trueChildEl, this.el);\n        this.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_SERVER_ERROR_CLASS\n        ]);\n        this.el = trueChildEl;\n      } else {\n        this.destroy();\n      }\n    }\n  }\n  onClose(reason) {\n    if (this.isDestroyed()) {\n      return;\n    }\n    if (this.isMain() && this.liveSocket.hasPendingLink() && reason !== \"leave\") {\n      return this.liveSocket.reloadWithJitter(this);\n    }\n    this.destroyAllChildren();\n    this.liveSocket.dropActiveElement(this);\n    if (this.liveSocket.isUnloaded()) {\n      this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n    }\n  }\n  onError(reason) {\n    this.onClose(reason);\n    if (this.liveSocket.isConnected()) {\n      this.log(\"error\", () => [\"view crashed\", reason]);\n    }\n    if (!this.liveSocket.isUnloaded()) {\n      if (this.liveSocket.isConnected()) {\n        this.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_SERVER_ERROR_CLASS\n        ]);\n      } else {\n        this.displayError([\n          PHX_LOADING_CLASS,\n          PHX_ERROR_CLASS,\n          PHX_CLIENT_ERROR_CLASS\n        ]);\n      }\n    }\n  }\n  displayError(classes) {\n    if (this.isMain()) {\n      dom_default.dispatchEvent(window, \"phx:page-loading-start\", {\n        detail: { to: this.href, kind: \"error\" }\n      });\n    }\n    this.showLoader();\n    this.setContainerClasses(...classes);\n    this.delayedDisconnected();\n  }\n  delayedDisconnected() {\n    this.disconnectedTimer = setTimeout(() => {\n      this.execAll(this.binding(\"disconnected\"));\n    }, this.liveSocket.disconnectedTimeout);\n  }\n  wrapPush(callerPush, receives) {\n    const latency = this.liveSocket.getLatencySim();\n    const withLatency = latency ? (cb) => setTimeout(() => !this.isDestroyed() && cb(), latency) : (cb) => !this.isDestroyed() && cb();\n    withLatency(() => {\n      callerPush().receive(\n        \"ok\",\n        (resp) => withLatency(() => receives.ok && receives.ok(resp))\n      ).receive(\n        \"error\",\n        (reason) => withLatency(() => receives.error && receives.error(reason))\n      ).receive(\n        \"timeout\",\n        () => withLatency(() => receives.timeout && receives.timeout())\n      );\n    });\n  }\n  pushWithReply(refGenerator, event, payload) {\n    if (!this.isConnected()) {\n      return Promise.reject(new Error(\"no connection\"));\n    }\n    const [ref, [el], opts] = refGenerator ? refGenerator({ payload }) : [null, [], {}];\n    const oldJoinCount = this.joinCount;\n    let onLoadingDone = function() {\n    };\n    if (opts.page_loading) {\n      onLoadingDone = this.liveSocket.withPageLoading({\n        kind: \"element\",\n        target: el\n      });\n    }\n    if (typeof payload.cid !== \"number\") {\n      delete payload.cid;\n    }\n    return new Promise((resolve, reject) => {\n      this.wrapPush(() => this.channel.push(event, payload, PUSH_TIMEOUT), {\n        ok: (resp) => {\n          if (ref !== null) {\n            this.lastAckRef = ref;\n          }\n          const finish = (hookReply) => {\n            if (resp.redirect) {\n              this.onRedirect(resp.redirect);\n            }\n            if (resp.live_patch) {\n              this.onLivePatch(resp.live_patch);\n            }\n            if (resp.live_redirect) {\n              this.onLiveRedirect(resp.live_redirect);\n            }\n            onLoadingDone();\n            resolve({ resp, reply: hookReply, ref });\n          };\n          if (resp.diff) {\n            this.liveSocket.requestDOMUpdate(() => {\n              this.applyDiff(\"update\", resp.diff, ({ diff, reply, events }) => {\n                if (ref !== null) {\n                  this.undoRefs(ref, payload.event);\n                }\n                this.update(diff, events);\n                finish(reply);\n              });\n            });\n          } else {\n            if (ref !== null) {\n              this.undoRefs(ref, payload.event);\n            }\n            finish(null);\n          }\n        },\n        error: (reason) => reject(new Error(`failed with reason: ${reason}`)),\n        timeout: () => {\n          reject(new Error(\"timeout\"));\n          if (this.joinCount === oldJoinCount) {\n            this.liveSocket.reloadWithJitter(this, () => {\n              this.log(\"timeout\", () => [\n                \"received timeout while communicating with server. Falling back to hard refresh for recovery\"\n              ]);\n            });\n          }\n        }\n      });\n    });\n  }\n  undoRefs(ref, phxEvent, onlyEls) {\n    if (!this.isConnected()) {\n      return;\n    }\n    const selector = `[${PHX_REF_SRC}=\"${this.refSrc()}\"]`;\n    if (onlyEls) {\n      onlyEls = new Set(onlyEls);\n      dom_default.all(document, selector, (parent) => {\n        if (onlyEls && !onlyEls.has(parent)) {\n          return;\n        }\n        dom_default.all(\n          parent,\n          selector,\n          (child) => this.undoElRef(child, ref, phxEvent)\n        );\n        this.undoElRef(parent, ref, phxEvent);\n      });\n    } else {\n      dom_default.all(document, selector, (el) => this.undoElRef(el, ref, phxEvent));\n    }\n  }\n  undoElRef(el, ref, phxEvent) {\n    const elRef = new ElementRef(el);\n    elRef.maybeUndo(ref, phxEvent, (clonedTree) => {\n      const patch = new DOMPatch(this, el, this.id, clonedTree, [], null, {\n        undoRef: ref\n      });\n      const phxChildrenAdded = this.performPatch(patch, true);\n      dom_default.all(\n        el,\n        `[${PHX_REF_SRC}=\"${this.refSrc()}\"]`,\n        (child) => this.undoElRef(child, ref, phxEvent)\n      );\n      if (phxChildrenAdded) {\n        this.joinNewChildren();\n      }\n    });\n  }\n  refSrc() {\n    return this.el.id;\n  }\n  putRef(elements, phxEvent, eventType, opts = {}) {\n    const newRef = this.ref++;\n    const disableWith = this.binding(PHX_DISABLE_WITH);\n    if (opts.loading) {\n      const loadingEls = dom_default.all(document, opts.loading).map((el) => {\n        return { el, lock: true, loading: true };\n      });\n      elements = elements.concat(loadingEls);\n    }\n    for (const { el, lock, loading } of elements) {\n      if (!lock && !loading) {\n        throw new Error(\"putRef requires lock or loading\");\n      }\n      el.setAttribute(PHX_REF_SRC, this.refSrc());\n      if (loading) {\n        el.setAttribute(PHX_REF_LOADING, newRef);\n      }\n      if (lock) {\n        el.setAttribute(PHX_REF_LOCK, newRef);\n      }\n      if (!loading || opts.submitter && !(el === opts.submitter || el === opts.form)) {\n        continue;\n      }\n      const lockCompletePromise = new Promise((resolve) => {\n        el.addEventListener(`phx:undo-lock:${newRef}`, () => resolve(detail), {\n          once: true\n        });\n      });\n      const loadingCompletePromise = new Promise((resolve) => {\n        el.addEventListener(\n          `phx:undo-loading:${newRef}`,\n          () => resolve(detail),\n          { once: true }\n        );\n      });\n      el.classList.add(`phx-${eventType}-loading`);\n      const disableText = el.getAttribute(disableWith);\n      if (disableText !== null) {\n        if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\n          el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\n        }\n        if (disableText !== \"\") {\n          el.innerText = disableText;\n        }\n        el.setAttribute(\n          PHX_DISABLED,\n          el.getAttribute(PHX_DISABLED) || el.disabled\n        );\n        el.setAttribute(\"disabled\", \"\");\n      }\n      const detail = {\n        event: phxEvent,\n        eventType,\n        ref: newRef,\n        isLoading: loading,\n        isLocked: lock,\n        lockElements: elements.filter(({ lock: lock2 }) => lock2).map(({ el: el2 }) => el2),\n        loadingElements: elements.filter(({ loading: loading2 }) => loading2).map(({ el: el2 }) => el2),\n        unlock: (els) => {\n          els = Array.isArray(els) ? els : [els];\n          this.undoRefs(newRef, phxEvent, els);\n        },\n        lockComplete: lockCompletePromise,\n        loadingComplete: loadingCompletePromise,\n        lock: (lockEl) => {\n          return new Promise((resolve) => {\n            if (this.isAcked(newRef)) {\n              return resolve(detail);\n            }\n            lockEl.setAttribute(PHX_REF_LOCK, newRef);\n            lockEl.setAttribute(PHX_REF_SRC, this.refSrc());\n            lockEl.addEventListener(\n              `phx:lock-stop:${newRef}`,\n              () => resolve(detail),\n              { once: true }\n            );\n          });\n        }\n      };\n      if (opts.payload) {\n        detail[\"payload\"] = opts.payload;\n      }\n      if (opts.target) {\n        detail[\"target\"] = opts.target;\n      }\n      if (opts.originalEvent) {\n        detail[\"originalEvent\"] = opts.originalEvent;\n      }\n      el.dispatchEvent(\n        new CustomEvent(\"phx:push\", {\n          detail,\n          bubbles: true,\n          cancelable: false\n        })\n      );\n      if (phxEvent) {\n        el.dispatchEvent(\n          new CustomEvent(`phx:push:${phxEvent}`, {\n            detail,\n            bubbles: true,\n            cancelable: false\n          })\n        );\n      }\n    }\n    return [newRef, elements.map(({ el }) => el), opts];\n  }\n  isAcked(ref) {\n    return this.lastAckRef !== null && this.lastAckRef >= ref;\n  }\n  componentID(el) {\n    const cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\n    return cid ? parseInt(cid) : null;\n  }\n  targetComponentID(target, targetCtx, opts = {}) {\n    if (isCid(targetCtx)) {\n      return targetCtx;\n    }\n    const cidOrSelector = opts.target || target.getAttribute(this.binding(\"target\"));\n    if (isCid(cidOrSelector)) {\n      return parseInt(cidOrSelector);\n    } else if (targetCtx && (cidOrSelector !== null || opts.target)) {\n      return this.closestComponentID(targetCtx);\n    } else {\n      return null;\n    }\n  }\n  closestComponentID(targetCtx) {\n    if (isCid(targetCtx)) {\n      return targetCtx;\n    } else if (targetCtx) {\n      return maybe(\n        targetCtx.closest(`[${PHX_COMPONENT}]`),\n        (el) => this.ownsElement(el) && this.componentID(el)\n      );\n    } else {\n      return null;\n    }\n  }\n  pushHookEvent(el, targetCtx, event, payload) {\n    if (!this.isConnected()) {\n      this.log(\"hook\", () => [\n        \"unable to push hook event. LiveView not connected\",\n        event,\n        payload\n      ]);\n      return Promise.reject(\n        new Error(\"unable to push hook event. LiveView not connected\")\n      );\n    }\n    const refGenerator = () => this.putRef([{ el, loading: true, lock: true }], event, \"hook\", {\n      payload,\n      target: targetCtx\n    });\n    return this.pushWithReply(refGenerator, \"event\", {\n      type: \"hook\",\n      event,\n      value: payload,\n      cid: this.closestComponentID(targetCtx)\n    }).then(({ resp: _resp, reply, ref }) => ({ reply, ref }));\n  }\n  extractMeta(el, meta, value) {\n    const prefix = this.binding(\"value-\");\n    for (let i = 0; i < el.attributes.length; i++) {\n      if (!meta) {\n        meta = {};\n      }\n      const name = el.attributes[i].name;\n      if (name.startsWith(prefix)) {\n        meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n      }\n    }\n    if (el.value !== void 0 && !(el instanceof HTMLFormElement)) {\n      if (!meta) {\n        meta = {};\n      }\n      meta.value = el.value;\n      if (el.tagName === \"INPUT\" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {\n        delete meta.value;\n      }\n    }\n    if (value) {\n      if (!meta) {\n        meta = {};\n      }\n      for (const key in value) {\n        meta[key] = value[key];\n      }\n    }\n    return meta;\n  }\n  pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}, onReply) {\n    this.pushWithReply(\n      (maybePayload) => this.putRef([{ el, loading: true, lock: true }], phxEvent, type, {\n        ...opts,\n        payload: maybePayload?.payload\n      }),\n      \"event\",\n      {\n        type,\n        event: phxEvent,\n        value: this.extractMeta(el, meta, opts.value),\n        cid: this.targetComponentID(el, targetCtx, opts)\n      }\n    ).then(({ reply }) => onReply && onReply(reply)).catch((error) => logError(\"Failed to push event\", error));\n  }\n  pushFileProgress(fileEl, entryRef, progress, onReply = function() {\n  }) {\n    this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {\n      view.pushWithReply(null, \"progress\", {\n        event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),\n        ref: fileEl.getAttribute(PHX_UPLOAD_REF),\n        entry_ref: entryRef,\n        progress,\n        cid: view.targetComponentID(fileEl.form, targetCtx)\n      }).then(() => onReply()).catch((error) => logError(\"Failed to push file progress\", error));\n    });\n  }\n  pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {\n    if (!inputEl.form) {\n      throw new Error(\"form events require the input to be inside a form\");\n    }\n    let uploads;\n    const cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx, opts);\n    const refGenerator = (maybePayload) => {\n      return this.putRef(\n        [\n          { el: inputEl, loading: true, lock: true },\n          { el: inputEl.form, loading: true, lock: true }\n        ],\n        phxEvent,\n        \"change\",\n        { ...opts, payload: maybePayload?.payload }\n      );\n    };\n    let formData;\n    const meta = this.extractMeta(inputEl.form, {}, opts.value);\n    const serializeOpts = {};\n    if (inputEl instanceof HTMLButtonElement) {\n      serializeOpts.submitter = inputEl;\n    }\n    if (inputEl.getAttribute(this.binding(\"change\"))) {\n      formData = serializeForm(inputEl.form, serializeOpts, [inputEl.name]);\n    } else {\n      formData = serializeForm(inputEl.form, serializeOpts);\n    }\n    if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {\n      LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));\n    }\n    uploads = LiveUploader.serializeUploads(inputEl);\n    const event = {\n      type: \"form\",\n      event: phxEvent,\n      value: formData,\n      meta: {\n        // no target was implicitly sent as \"undefined\" in LV <= 1.0.5, therefore\n        // we have to keep it. In 1.0.6 we switched from passing meta as URL encoded data\n        // to passing it directly in the event, but the JSON encode would drop keys with\n        // undefined values.\n        _target: opts._target || \"undefined\",\n        ...meta\n      },\n      uploads,\n      cid\n    };\n    this.pushWithReply(refGenerator, \"event\", event).then(({ resp }) => {\n      if (dom_default.isUploadInput(inputEl) && dom_default.isAutoUpload(inputEl)) {\n        ElementRef.onUnlock(inputEl, () => {\n          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {\n            const [ref, _els] = refGenerator();\n            this.undoRefs(ref, phxEvent, [inputEl.form]);\n            this.uploadFiles(\n              inputEl.form,\n              phxEvent,\n              targetCtx,\n              ref,\n              cid,\n              (_uploads) => {\n                callback && callback(resp);\n                this.triggerAwaitingSubmit(inputEl.form, phxEvent);\n                this.undoRefs(ref, phxEvent);\n              }\n            );\n          }\n        });\n      } else {\n        callback && callback(resp);\n      }\n    }).catch((error) => logError(\"Failed to push input event\", error));\n  }\n  triggerAwaitingSubmit(formEl, phxEvent) {\n    const awaitingSubmit = this.getScheduledSubmit(formEl);\n    if (awaitingSubmit) {\n      const [_el, _ref, _opts, callback] = awaitingSubmit;\n      this.cancelSubmit(formEl, phxEvent);\n      callback();\n    }\n  }\n  getScheduledSubmit(formEl) {\n    return this.formSubmits.find(\n      ([el, _ref, _opts, _callback]) => el.isSameNode(formEl)\n    );\n  }\n  scheduleSubmit(formEl, ref, opts, callback) {\n    if (this.getScheduledSubmit(formEl)) {\n      return true;\n    }\n    this.formSubmits.push([formEl, ref, opts, callback]);\n  }\n  cancelSubmit(formEl, phxEvent) {\n    this.formSubmits = this.formSubmits.filter(\n      ([el, ref, _opts, _callback]) => {\n        if (el.isSameNode(formEl)) {\n          this.undoRefs(ref, phxEvent);\n          return false;\n        } else {\n          return true;\n        }\n      }\n    );\n  }\n  disableForm(formEl, phxEvent, opts = {}) {\n    const filterIgnored = (el) => {\n      const userIgnored = closestPhxBinding(\n        el,\n        `${this.binding(PHX_UPDATE)}=ignore`,\n        el.form\n      );\n      return !(userIgnored || closestPhxBinding(el, \"data-phx-update=ignore\", el.form));\n    };\n    const filterDisables = (el) => {\n      return el.hasAttribute(this.binding(PHX_DISABLE_WITH));\n    };\n    const filterButton = (el) => el.tagName == \"BUTTON\";\n    const filterInput = (el) => [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(el.tagName);\n    const formElements = Array.from(formEl.elements);\n    const disables = formElements.filter(filterDisables);\n    const buttons = formElements.filter(filterButton).filter(filterIgnored);\n    const inputs = formElements.filter(filterInput).filter(filterIgnored);\n    buttons.forEach((button) => {\n      button.setAttribute(PHX_DISABLED, button.disabled);\n      button.disabled = true;\n    });\n    inputs.forEach((input) => {\n      input.setAttribute(PHX_READONLY, input.readOnly);\n      input.readOnly = true;\n      if (input.files) {\n        input.setAttribute(PHX_DISABLED, input.disabled);\n        input.disabled = true;\n      }\n    });\n    const formEls = disables.concat(buttons).concat(inputs).map((el) => {\n      return { el, loading: true, lock: true };\n    });\n    const els = [{ el: formEl, loading: true, lock: false }].concat(formEls).reverse();\n    return this.putRef(els, phxEvent, \"submit\", opts);\n  }\n  pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {\n    const refGenerator = (maybePayload) => this.disableForm(formEl, phxEvent, {\n      ...opts,\n      form: formEl,\n      payload: maybePayload?.payload,\n      submitter\n    });\n    dom_default.putPrivate(formEl, \"submitter\", submitter);\n    const cid = this.targetComponentID(formEl, targetCtx);\n    if (LiveUploader.hasUploadsInProgress(formEl)) {\n      const [ref, _els] = refGenerator();\n      const push = () => this.pushFormSubmit(\n        formEl,\n        targetCtx,\n        phxEvent,\n        submitter,\n        opts,\n        onReply\n      );\n      return this.scheduleSubmit(formEl, ref, opts, push);\n    } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n      const [ref, els] = refGenerator();\n      const proxyRefGen = () => [ref, els, opts];\n      this.uploadFiles(formEl, phxEvent, targetCtx, ref, cid, (_uploads) => {\n        if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n          return this.undoRefs(ref, phxEvent);\n        }\n        const meta = this.extractMeta(formEl, {}, opts.value);\n        const formData = serializeForm(formEl, { submitter });\n        this.pushWithReply(proxyRefGen, \"event\", {\n          type: \"form\",\n          event: phxEvent,\n          value: formData,\n          meta,\n          cid\n        }).then(({ resp }) => onReply(resp)).catch((error) => logError(\"Failed to push form submit\", error));\n      });\n    } else if (!(formEl.hasAttribute(PHX_REF_SRC) && formEl.classList.contains(\"phx-submit-loading\"))) {\n      const meta = this.extractMeta(formEl, {}, opts.value);\n      const formData = serializeForm(formEl, { submitter });\n      this.pushWithReply(refGenerator, \"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: formData,\n        meta,\n        cid\n      }).then(({ resp }) => onReply(resp)).catch((error) => logError(\"Failed to push form submit\", error));\n    }\n  }\n  uploadFiles(formEl, phxEvent, targetCtx, ref, cid, onComplete) {\n    const joinCountAtUpload = this.joinCount;\n    const inputEls = LiveUploader.activeFileInputs(formEl);\n    let numFileInputsInProgress = inputEls.length;\n    inputEls.forEach((inputEl) => {\n      const uploader = new LiveUploader(inputEl, this, () => {\n        numFileInputsInProgress--;\n        if (numFileInputsInProgress === 0) {\n          onComplete();\n        }\n      });\n      const entries = uploader.entries().map((entry) => entry.toPreflightPayload());\n      if (entries.length === 0) {\n        numFileInputsInProgress--;\n        return;\n      }\n      const payload = {\n        ref: inputEl.getAttribute(PHX_UPLOAD_REF),\n        entries,\n        cid: this.targetComponentID(inputEl.form, targetCtx)\n      };\n      this.log(\"upload\", () => [\"sending preflight request\", payload]);\n      this.pushWithReply(null, \"allow_upload\", payload).then(({ resp }) => {\n        this.log(\"upload\", () => [\"got preflight response\", resp]);\n        uploader.entries().forEach((entry) => {\n          if (resp.entries && !resp.entries[entry.ref]) {\n            this.handleFailedEntryPreflight(\n              entry.ref,\n              \"failed preflight\",\n              uploader\n            );\n          }\n        });\n        if (resp.error || Object.keys(resp.entries).length === 0) {\n          this.undoRefs(ref, phxEvent);\n          const errors = resp.error || [];\n          errors.map(([entry_ref, reason]) => {\n            this.handleFailedEntryPreflight(entry_ref, reason, uploader);\n          });\n        } else {\n          const onError = (callback) => {\n            this.channel.onError(() => {\n              if (this.joinCount === joinCountAtUpload) {\n                callback();\n              }\n            });\n          };\n          uploader.initAdapterUpload(resp, onError, this.liveSocket);\n        }\n      }).catch((error) => logError(\"Failed to push upload\", error));\n    });\n  }\n  handleFailedEntryPreflight(uploadRef, reason, uploader) {\n    if (uploader.isAutoUpload()) {\n      const entry = uploader.entries().find((entry2) => entry2.ref === uploadRef.toString());\n      if (entry) {\n        entry.cancel();\n      }\n    } else {\n      uploader.entries().map((entry) => entry.cancel());\n    }\n    this.log(\"upload\", () => [`error for entry ${uploadRef}`, reason]);\n  }\n  dispatchUploads(targetCtx, name, filesOrBlobs) {\n    const targetElement = this.targetCtxElement(targetCtx) || this.el;\n    const inputs = dom_default.findUploadInputs(targetElement).filter(\n      (el) => el.name === name\n    );\n    if (inputs.length === 0) {\n      logError(`no live file inputs found matching the name \"${name}\"`);\n    } else if (inputs.length > 1) {\n      logError(`duplicate live file inputs found matching the name \"${name}\"`);\n    } else {\n      dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, {\n        detail: { files: filesOrBlobs }\n      });\n    }\n  }\n  targetCtxElement(targetCtx) {\n    if (isCid(targetCtx)) {\n      const [target] = dom_default.findComponentNodeList(this.id, targetCtx);\n      return target;\n    } else if (targetCtx) {\n      return targetCtx;\n    } else {\n      return null;\n    }\n  }\n  pushFormRecovery(oldForm, newForm, templateDom, callback) {\n    const phxChange = this.binding(\"change\");\n    const phxTarget = newForm.getAttribute(this.binding(\"target\")) || newForm;\n    const phxEvent = newForm.getAttribute(this.binding(PHX_AUTO_RECOVER)) || newForm.getAttribute(this.binding(\"change\"));\n    const inputs = Array.from(oldForm.elements).filter(\n      (el) => dom_default.isFormInput(el) && el.name && !el.hasAttribute(phxChange)\n    );\n    if (inputs.length === 0) {\n      callback();\n      return;\n    }\n    inputs.forEach(\n      (input2) => input2.hasAttribute(PHX_UPLOAD_REF) && LiveUploader.clearFiles(input2)\n    );\n    const input = inputs.find((el) => el.type !== \"hidden\") || inputs[0];\n    let pending = 0;\n    this.withinTargets(\n      phxTarget,\n      (targetView, targetCtx) => {\n        const cid = this.targetComponentID(newForm, targetCtx);\n        pending++;\n        let e = new CustomEvent(\"phx:form-recovery\", {\n          detail: { sourceElement: oldForm }\n        });\n        js_default.exec(e, \"change\", phxEvent, this, input, [\n          \"push\",\n          {\n            _target: input.name,\n            targetView,\n            targetCtx,\n            newCid: cid,\n            callback: () => {\n              pending--;\n              if (pending === 0) {\n                callback();\n              }\n            }\n          }\n        ]);\n      },\n      templateDom\n    );\n  }\n  pushLinkPatch(e, href, targetEl, callback) {\n    const linkRef = this.liveSocket.setPendingLink(href);\n    const loading = e.isTrusted && e.type !== \"popstate\";\n    const refGen = targetEl ? () => this.putRef(\n      [{ el: targetEl, loading, lock: true }],\n      null,\n      \"click\"\n    ) : null;\n    const fallback = () => this.liveSocket.redirect(window.location.href);\n    const url = href.startsWith(\"/\") ? `${location.protocol}//${location.host}${href}` : href;\n    this.pushWithReply(refGen, \"live_patch\", { url }).then(\n      ({ resp }) => {\n        this.liveSocket.requestDOMUpdate(() => {\n          if (resp.link_redirect) {\n            this.liveSocket.replaceMain(href, null, callback, linkRef);\n          } else {\n            if (this.liveSocket.commitPendingLink(linkRef)) {\n              this.href = href;\n            }\n            this.applyPendingUpdates();\n            callback && callback(linkRef);\n          }\n        });\n      },\n      ({ error: _error, timeout: _timeout }) => fallback()\n    );\n  }\n  getFormsForRecovery() {\n    if (this.joinCount === 0) {\n      return {};\n    }\n    const phxChange = this.binding(\"change\");\n    return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id).filter((form) => form.elements.length > 0).filter(\n      (form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== \"ignore\"\n    ).map((form) => {\n      const clonedForm = form.cloneNode(true);\n      morphdom_esm_default(clonedForm, form, {\n        onBeforeElUpdated: (fromEl, toEl) => {\n          dom_default.copyPrivates(fromEl, toEl);\n          return true;\n        }\n      });\n      const externalElements = document.querySelectorAll(\n        `[form=\"${form.id}\"]`\n      );\n      Array.from(externalElements).forEach((el) => {\n        if (form.contains(el)) {\n          return;\n        }\n        const clonedEl = el.cloneNode(true);\n        morphdom_esm_default(clonedEl, el);\n        dom_default.copyPrivates(clonedEl, el);\n        clonedForm.appendChild(clonedEl);\n      });\n      return clonedForm;\n    }).reduce((acc, form) => {\n      acc[form.id] = form;\n      return acc;\n    }, {});\n  }\n  maybePushComponentsDestroyed(destroyedCIDs) {\n    let willDestroyCIDs = destroyedCIDs.filter((cid) => {\n      return dom_default.findComponentNodeList(this.el, cid).length === 0;\n    });\n    const onError = (error) => {\n      if (!this.isDestroyed()) {\n        logError(\"Failed to push components destroyed\", error);\n      }\n    };\n    if (willDestroyCIDs.length > 0) {\n      willDestroyCIDs.forEach((cid) => this.rendered.resetRender(cid));\n      this.pushWithReply(null, \"cids_will_destroy\", { cids: willDestroyCIDs }).then(() => {\n        this.liveSocket.requestDOMUpdate(() => {\n          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {\n            return dom_default.findComponentNodeList(this.el, cid).length === 0;\n          });\n          if (completelyDestroyCIDs.length > 0) {\n            this.pushWithReply(null, \"cids_destroyed\", {\n              cids: completelyDestroyCIDs\n            }).then(({ resp }) => {\n              this.rendered.pruneCIDs(resp.cids);\n            }).catch(onError);\n          }\n        });\n      }).catch(onError);\n    }\n  }\n  ownsElement(el) {\n    let parentViewEl = dom_default.closestViewEl(el);\n    return el.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;\n  }\n  submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {\n    dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);\n    const inputs = Array.from(form.elements);\n    inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));\n    this.liveSocket.blurActiveElement(this);\n    this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {\n      this.liveSocket.restorePreviouslyActiveFocus();\n    });\n  }\n  binding(kind) {\n    return this.liveSocket.binding(kind);\n  }\n  // phx-portal\n  pushPortalElementId(id) {\n    this.portalElementIds.add(id);\n  }\n  dropPortalElementId(id) {\n    this.portalElementIds.delete(id);\n  }\n  destroyPortalElements() {\n    this.portalElementIds.forEach((id) => {\n      const el = document.getElementById(id);\n      if (el) {\n        el.remove();\n      }\n    });\n  }\n};\n\n// js/phoenix_live_view/live_socket.js\nvar isUsedInput = (el) => dom_default.isUsedInput(el);\nvar LiveSocket = class {\n  constructor(url, phxSocket, opts = {}) {\n    this.unloaded = false;\n    if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n      throw new Error(`\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\n\n          import {Socket} from \"phoenix\"\n          import {LiveSocket} from \"phoenix_live_view\"\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n      `);\n    }\n    this.socket = new phxSocket(url, opts);\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n    this.opts = opts;\n    this.params = closure(opts.params || {});\n    this.viewLogger = opts.viewLogger;\n    this.metadataCallbacks = opts.metadata || {};\n    this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\n    this.prevActive = null;\n    this.silenced = false;\n    this.main = null;\n    this.outgoingMainEl = null;\n    this.clickStartedAtTarget = null;\n    this.linkRef = 1;\n    this.roots = {};\n    this.href = window.location.href;\n    this.pendingLink = null;\n    this.currentLocation = clone(window.location);\n    this.hooks = opts.hooks || {};\n    this.uploaders = opts.uploaders || {};\n    this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\n    this.disconnectedTimeout = opts.disconnectedTimeout || DISCONNECTED_TIMEOUT;\n    this.reloadWithJitterTimer = null;\n    this.maxReloads = opts.maxReloads || MAX_RELOADS;\n    this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;\n    this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;\n    this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;\n    this.localStorage = opts.localStorage || window.localStorage;\n    this.sessionStorage = opts.sessionStorage || window.sessionStorage;\n    this.boundTopLevelEvents = false;\n    this.boundEventNames = /* @__PURE__ */ new Set();\n    this.blockPhxChangeWhileComposing = opts.blockPhxChangeWhileComposing || false;\n    this.serverCloseRef = null;\n    this.domCallbacks = Object.assign(\n      {\n        jsQuerySelectorAll: null,\n        onPatchStart: closure(),\n        onPatchEnd: closure(),\n        onNodeAdded: closure(),\n        onBeforeElUpdated: closure()\n      },\n      opts.dom || {}\n    );\n    this.transitions = new TransitionSet();\n    this.currentHistoryPosition = parseInt(this.sessionStorage.getItem(PHX_LV_HISTORY_POSITION)) || 0;\n    window.addEventListener(\"pagehide\", (_e) => {\n      this.unloaded = true;\n    });\n    this.socket.onOpen(() => {\n      if (this.isUnloaded()) {\n        window.location.reload();\n      }\n    });\n  }\n  // public\n  version() {\n    return \"1.1.8\";\n  }\n  isProfileEnabled() {\n    return this.sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\n  }\n  isDebugEnabled() {\n    return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\n  }\n  isDebugDisabled() {\n    return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"false\";\n  }\n  enableDebug() {\n    this.sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\n  }\n  enableProfiling() {\n    this.sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\n  }\n  disableDebug() {\n    this.sessionStorage.setItem(PHX_LV_DEBUG, \"false\");\n  }\n  disableProfiling() {\n    this.sessionStorage.removeItem(PHX_LV_PROFILE);\n  }\n  enableLatencySim(upperBoundMs) {\n    this.enableDebug();\n    console.log(\n      \"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\"\n    );\n    this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\n  }\n  disableLatencySim() {\n    this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\n  }\n  getLatencySim() {\n    const str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);\n    return str ? parseInt(str) : null;\n  }\n  getSocket() {\n    return this.socket;\n  }\n  connect() {\n    if (window.location.hostname === \"localhost\" && !this.isDebugDisabled()) {\n      this.enableDebug();\n    }\n    const doConnect = () => {\n      this.resetReloadStatus();\n      if (this.joinRootViews()) {\n        this.bindTopLevelEvents();\n        this.socket.connect();\n      } else if (this.main) {\n        this.socket.connect();\n      } else {\n        this.bindTopLevelEvents({ dead: true });\n      }\n      this.joinDeadView();\n    };\n    if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n      doConnect();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => doConnect());\n    }\n  }\n  disconnect(callback) {\n    clearTimeout(this.reloadWithJitterTimer);\n    if (this.serverCloseRef) {\n      this.socket.off(this.serverCloseRef);\n      this.serverCloseRef = null;\n    }\n    this.socket.disconnect(callback);\n  }\n  replaceTransport(transport) {\n    clearTimeout(this.reloadWithJitterTimer);\n    this.socket.replaceTransport(transport);\n    this.connect();\n  }\n  execJS(el, encodedJS, eventType = null) {\n    const e = new CustomEvent(\"phx:exec\", { detail: { sourceElement: el } });\n    this.owner(el, (view) => js_default.exec(e, eventType, encodedJS, view, el));\n  }\n  /**\n   * Returns an object with methods to manipluate the DOM and execute JavaScript.\n   * The applied changes integrate with server DOM patching.\n   *\n   * @returns {import(\"./js_commands\").LiveSocketJSCommands}\n   */\n  js() {\n    return js_commands_default(this, \"js\");\n  }\n  // private\n  unload() {\n    if (this.unloaded) {\n      return;\n    }\n    if (this.main && this.isConnected()) {\n      this.log(this.main, \"socket\", () => [\"disconnect for page nav\"]);\n    }\n    this.unloaded = true;\n    this.destroyAllViews();\n    this.disconnect();\n  }\n  triggerDOM(kind, args) {\n    this.domCallbacks[kind](...args);\n  }\n  time(name, func) {\n    if (!this.isProfileEnabled() || !console.time) {\n      return func();\n    }\n    console.time(name);\n    const result = func();\n    console.timeEnd(name);\n    return result;\n  }\n  log(view, kind, msgCallback) {\n    if (this.viewLogger) {\n      const [msg, obj] = msgCallback();\n      this.viewLogger(view, kind, msg, obj);\n    } else if (this.isDebugEnabled()) {\n      const [msg, obj] = msgCallback();\n      debug(view, kind, msg, obj);\n    }\n  }\n  requestDOMUpdate(callback) {\n    this.transitions.after(callback);\n  }\n  asyncTransition(promise) {\n    this.transitions.addAsyncTransition(promise);\n  }\n  transition(time, onStart, onDone = function() {\n  }) {\n    this.transitions.addTransition(time, onStart, onDone);\n  }\n  onChannel(channel, event, cb) {\n    channel.on(event, (data) => {\n      const latency = this.getLatencySim();\n      if (!latency) {\n        cb(data);\n      } else {\n        setTimeout(() => cb(data), latency);\n      }\n    });\n  }\n  reloadWithJitter(view, log) {\n    clearTimeout(this.reloadWithJitterTimer);\n    this.disconnect();\n    const minMs = this.reloadJitterMin;\n    const maxMs = this.reloadJitterMax;\n    let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n    const tries = browser_default.updateLocal(\n      this.localStorage,\n      window.location.pathname,\n      CONSECUTIVE_RELOADS,\n      0,\n      (count) => count + 1\n    );\n    if (tries >= this.maxReloads) {\n      afterMs = this.failsafeJitter;\n    }\n    this.reloadWithJitterTimer = setTimeout(() => {\n      if (view.isDestroyed() || view.isConnected()) {\n        return;\n      }\n      view.destroy();\n      log ? log() : this.log(view, \"join\", () => [\n        `encountered ${tries} consecutive reloads`\n      ]);\n      if (tries >= this.maxReloads) {\n        this.log(view, \"join\", () => [\n          `exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`\n        ]);\n      }\n      if (this.hasPendingLink()) {\n        window.location = this.pendingLink;\n      } else {\n        window.location.reload();\n      }\n    }, afterMs);\n  }\n  getHookDefinition(name) {\n    if (!name) {\n      return;\n    }\n    return this.maybeInternalHook(name) || this.hooks[name] || this.maybeRuntimeHook(name);\n  }\n  maybeInternalHook(name) {\n    return name && name.startsWith(\"Phoenix.\") && hooks_default[name.split(\".\")[1]];\n  }\n  maybeRuntimeHook(name) {\n    const runtimeHook = document.querySelector(\n      `script[${PHX_RUNTIME_HOOK}=\"${CSS.escape(name)}\"]`\n    );\n    if (!runtimeHook) {\n      return;\n    }\n    let callbacks = window[`phx_hook_${name}`];\n    if (!callbacks || typeof callbacks !== \"function\") {\n      logError(\"a runtime hook must be a function\", runtimeHook);\n      return;\n    }\n    const hookDefiniton = callbacks();\n    if (hookDefiniton && (typeof hookDefiniton === \"object\" || typeof hookDefiniton === \"function\")) {\n      return hookDefiniton;\n    }\n    logError(\n      \"runtime hook must return an object with hook callbacks or an instance of ViewHook\",\n      runtimeHook\n    );\n  }\n  isUnloaded() {\n    return this.unloaded;\n  }\n  isConnected() {\n    return this.socket.isConnected();\n  }\n  getBindingPrefix() {\n    return this.bindingPrefix;\n  }\n  binding(kind) {\n    return `${this.getBindingPrefix()}${kind}`;\n  }\n  channel(topic, params) {\n    return this.socket.channel(topic, params);\n  }\n  joinDeadView() {\n    const body = document.body;\n    if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {\n      const view = this.newRootView(body);\n      view.setHref(this.getHref());\n      view.joinDead();\n      if (!this.main) {\n        this.main = view;\n      }\n      window.requestAnimationFrame(() => {\n        view.execNewMounted();\n        this.maybeScroll(history.state?.scroll);\n      });\n    }\n  }\n  joinRootViews() {\n    let rootsFound = false;\n    dom_default.all(\n      document,\n      `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`,\n      (rootEl) => {\n        if (!this.getRootById(rootEl.id)) {\n          const view = this.newRootView(rootEl);\n          if (!dom_default.isPhxSticky(rootEl)) {\n            view.setHref(this.getHref());\n          }\n          view.join();\n          if (rootEl.hasAttribute(PHX_MAIN)) {\n            this.main = view;\n          }\n        }\n        rootsFound = true;\n      }\n    );\n    return rootsFound;\n  }\n  redirect(to, flash, reloadToken) {\n    if (reloadToken) {\n      browser_default.setCookie(PHX_RELOAD_STATUS, reloadToken, 60);\n    }\n    this.unload();\n    browser_default.redirect(to, flash);\n  }\n  replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {\n    const liveReferer = this.currentLocation.href;\n    this.outgoingMainEl = this.outgoingMainEl || this.main.el;\n    const stickies = dom_default.findPhxSticky(document) || [];\n    const removeEls = dom_default.all(\n      this.outgoingMainEl,\n      `[${this.binding(\"remove\")}]`\n    ).filter((el) => !dom_default.isChildOfAny(el, stickies));\n    const newMainEl = dom_default.cloneNode(this.outgoingMainEl, \"\");\n    this.main.showLoader(this.loaderTimeout);\n    this.main.destroy();\n    this.main = this.newRootView(newMainEl, flash, liveReferer);\n    this.main.setRedirect(href);\n    this.transitionRemoves(removeEls);\n    this.main.join((joinCount, onDone) => {\n      if (joinCount === 1 && this.commitPendingLink(linkRef)) {\n        this.requestDOMUpdate(() => {\n          removeEls.forEach((el) => el.remove());\n          stickies.forEach((el) => newMainEl.appendChild(el));\n          this.outgoingMainEl.replaceWith(newMainEl);\n          this.outgoingMainEl = null;\n          callback && callback(linkRef);\n          onDone();\n        });\n      }\n    });\n  }\n  transitionRemoves(elements, callback) {\n    const removeAttr = this.binding(\"remove\");\n    const silenceEvents = (e) => {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n    };\n    elements.forEach((el) => {\n      for (const event of this.boundEventNames) {\n        el.addEventListener(event, silenceEvents, true);\n      }\n      this.execJS(el, el.getAttribute(removeAttr), \"remove\");\n    });\n    this.requestDOMUpdate(() => {\n      elements.forEach((el) => {\n        for (const event of this.boundEventNames) {\n          el.removeEventListener(event, silenceEvents, true);\n        }\n      });\n      callback && callback();\n    });\n  }\n  isPhxView(el) {\n    return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;\n  }\n  newRootView(el, flash, liveReferer) {\n    const view = new View(el, this, null, flash, liveReferer);\n    this.roots[view.id] = view;\n    return view;\n  }\n  owner(childEl, callback) {\n    let view;\n    const viewEl = dom_default.closestViewEl(childEl);\n    if (viewEl) {\n      view = this.getViewByEl(viewEl);\n    } else {\n      view = this.main;\n    }\n    return view && callback ? callback(view) : view;\n  }\n  withinOwners(childEl, callback) {\n    this.owner(childEl, (view) => callback(view, childEl));\n  }\n  getViewByEl(el) {\n    const rootId = el.getAttribute(PHX_ROOT_ID);\n    return maybe(\n      this.getRootById(rootId),\n      (root) => root.getDescendentByEl(el)\n    );\n  }\n  getRootById(id) {\n    return this.roots[id];\n  }\n  destroyAllViews() {\n    for (const id in this.roots) {\n      this.roots[id].destroy();\n      delete this.roots[id];\n    }\n    this.main = null;\n  }\n  destroyViewByEl(el) {\n    const root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\n    if (root && root.id === el.id) {\n      root.destroy();\n      delete this.roots[root.id];\n    } else if (root) {\n      root.destroyDescendent(el.id);\n    }\n  }\n  getActiveElement() {\n    return document.activeElement;\n  }\n  dropActiveElement(view) {\n    if (this.prevActive && view.ownsElement(this.prevActive)) {\n      this.prevActive = null;\n    }\n  }\n  restorePreviouslyActiveFocus() {\n    if (this.prevActive && this.prevActive !== document.body && this.prevActive instanceof HTMLElement) {\n      this.prevActive.focus();\n    }\n  }\n  blurActiveElement() {\n    this.prevActive = this.getActiveElement();\n    if (this.prevActive !== document.body && this.prevActive instanceof HTMLElement) {\n      this.prevActive.blur();\n    }\n  }\n  /**\n   * @param {{dead?: boolean}} [options={}]\n   */\n  bindTopLevelEvents({ dead } = {}) {\n    if (this.boundTopLevelEvents) {\n      return;\n    }\n    this.boundTopLevelEvents = true;\n    this.serverCloseRef = this.socket.onClose((event) => {\n      if (event && event.code === 1e3 && this.main) {\n        return this.reloadWithJitter(this.main);\n      }\n    });\n    document.body.addEventListener(\"click\", function() {\n    });\n    window.addEventListener(\n      \"pageshow\",\n      (e) => {\n        if (e.persisted) {\n          this.getSocket().disconnect();\n          this.withPageLoading({ to: window.location.href, kind: \"redirect\" });\n          window.location.reload();\n        }\n      },\n      true\n    );\n    if (!dead) {\n      this.bindNav();\n    }\n    this.bindClicks();\n    if (!dead) {\n      this.bindForms();\n    }\n    this.bind(\n      { keyup: \"keyup\", keydown: \"keydown\" },\n      (e, type, view, targetEl, phxEvent, _phxTarget) => {\n        const matchKey = targetEl.getAttribute(this.binding(PHX_KEY));\n        const pressedKey = e.key && e.key.toLowerCase();\n        if (matchKey && matchKey.toLowerCase() !== pressedKey) {\n          return;\n        }\n        const data = { key: e.key, ...this.eventMeta(type, e, targetEl) };\n        js_default.exec(e, type, phxEvent, view, targetEl, [\"push\", { data }]);\n      }\n    );\n    this.bind(\n      { blur: \"focusout\", focus: \"focusin\" },\n      (e, type, view, targetEl, phxEvent, phxTarget) => {\n        if (!phxTarget) {\n          const data = { key: e.key, ...this.eventMeta(type, e, targetEl) };\n          js_default.exec(e, type, phxEvent, view, targetEl, [\"push\", { data }]);\n        }\n      }\n    );\n    this.bind(\n      { blur: \"blur\", focus: \"focus\" },\n      (e, type, view, targetEl, phxEvent, phxTarget) => {\n        if (phxTarget === \"window\") {\n          const data = this.eventMeta(type, e, targetEl);\n          js_default.exec(e, type, phxEvent, view, targetEl, [\"push\", { data }]);\n        }\n      }\n    );\n    this.on(\"dragover\", (e) => e.preventDefault());\n    this.on(\"drop\", (e) => {\n      e.preventDefault();\n      const dropTargetId = maybe(\n        closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)),\n        (trueTarget) => {\n          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));\n        }\n      );\n      const dropTarget = dropTargetId && document.getElementById(dropTargetId);\n      const files = Array.from(e.dataTransfer.files || []);\n      if (!dropTarget || !(dropTarget instanceof HTMLInputElement) || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {\n        return;\n      }\n      LiveUploader.trackFiles(dropTarget, files, e.dataTransfer);\n      dropTarget.dispatchEvent(new Event(\"input\", { bubbles: true }));\n    });\n    this.on(PHX_TRACK_UPLOADS, (e) => {\n      const uploadTarget = e.target;\n      if (!dom_default.isUploadInput(uploadTarget)) {\n        return;\n      }\n      const files = Array.from(e.detail.files || []).filter(\n        (f) => f instanceof File || f instanceof Blob\n      );\n      LiveUploader.trackFiles(uploadTarget, files);\n      uploadTarget.dispatchEvent(new Event(\"input\", { bubbles: true }));\n    });\n  }\n  eventMeta(eventName, e, targetEl) {\n    const callback = this.metadataCallbacks[eventName];\n    return callback ? callback(e, targetEl) : {};\n  }\n  setPendingLink(href) {\n    this.linkRef++;\n    this.pendingLink = href;\n    this.resetReloadStatus();\n    return this.linkRef;\n  }\n  // anytime we are navigating or connecting, drop reload cookie in case\n  // we issue the cookie but the next request was interrupted and the server never dropped it\n  resetReloadStatus() {\n    browser_default.deleteCookie(PHX_RELOAD_STATUS);\n  }\n  commitPendingLink(linkRef) {\n    if (this.linkRef !== linkRef) {\n      return false;\n    } else {\n      this.href = this.pendingLink;\n      this.pendingLink = null;\n      return true;\n    }\n  }\n  getHref() {\n    return this.href;\n  }\n  hasPendingLink() {\n    return !!this.pendingLink;\n  }\n  bind(events, callback) {\n    for (const event in events) {\n      const browserEventName = events[event];\n      this.on(browserEventName, (e) => {\n        const binding = this.binding(event);\n        const windowBinding = this.binding(`window-${event}`);\n        const targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n        if (targetPhxEvent) {\n          this.debounce(e.target, e, browserEventName, () => {\n            this.withinOwners(e.target, (view) => {\n              callback(e, event, view, e.target, targetPhxEvent, null);\n            });\n          });\n        } else {\n          dom_default.all(document, `[${windowBinding}]`, (el) => {\n            const phxEvent = el.getAttribute(windowBinding);\n            this.debounce(el, e, browserEventName, () => {\n              this.withinOwners(el, (view) => {\n                callback(e, event, view, el, phxEvent, \"window\");\n              });\n            });\n          });\n        }\n      });\n    }\n  }\n  bindClicks() {\n    this.on(\"mousedown\", (e) => this.clickStartedAtTarget = e.target);\n    this.bindClick(\"click\", \"click\");\n  }\n  bindClick(eventName, bindingName) {\n    const click = this.binding(bindingName);\n    window.addEventListener(\n      eventName,\n      (e) => {\n        let target = null;\n        if (e.detail === 0)\n          this.clickStartedAtTarget = e.target;\n        const clickStartedAtTarget = this.clickStartedAtTarget || e.target;\n        target = closestPhxBinding(e.target, click);\n        this.dispatchClickAway(e, clickStartedAtTarget);\n        this.clickStartedAtTarget = null;\n        const phxEvent = target && target.getAttribute(click);\n        if (!phxEvent) {\n          if (dom_default.isNewPageClick(e, window.location)) {\n            this.unload();\n          }\n          return;\n        }\n        if (target.getAttribute(\"href\") === \"#\") {\n          e.preventDefault();\n        }\n        if (target.hasAttribute(PHX_REF_SRC)) {\n          return;\n        }\n        this.debounce(target, e, \"click\", () => {\n          this.withinOwners(target, (view) => {\n            js_default.exec(e, \"click\", phxEvent, view, target, [\n              \"push\",\n              { data: this.eventMeta(\"click\", e, target) }\n            ]);\n          });\n        });\n      },\n      false\n    );\n  }\n  dispatchClickAway(e, clickStartedAt) {\n    const phxClickAway = this.binding(\"click-away\");\n    dom_default.all(document, `[${phxClickAway}]`, (el) => {\n      if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {\n        this.withinOwners(el, (view) => {\n          const phxEvent = el.getAttribute(phxClickAway);\n          if (js_default.isVisible(el) && js_default.isInViewport(el)) {\n            js_default.exec(e, \"click\", phxEvent, view, el, [\n              \"push\",\n              { data: this.eventMeta(\"click\", e, e.target) }\n            ]);\n          }\n        });\n      }\n    });\n  }\n  bindNav() {\n    if (!browser_default.canPushState()) {\n      return;\n    }\n    if (history.scrollRestoration) {\n      history.scrollRestoration = \"manual\";\n    }\n    let scrollTimer = null;\n    window.addEventListener(\"scroll\", (_e) => {\n      clearTimeout(scrollTimer);\n      scrollTimer = setTimeout(() => {\n        browser_default.updateCurrentState(\n          (state) => Object.assign(state, { scroll: window.scrollY })\n        );\n      }, 100);\n    });\n    window.addEventListener(\n      \"popstate\",\n      (event) => {\n        if (!this.registerNewLocation(window.location)) {\n          return;\n        }\n        const { type, backType, id, scroll, position } = event.state || {};\n        const href = window.location.href;\n        const isForward = position > this.currentHistoryPosition;\n        const navType = isForward ? type : backType || type;\n        this.currentHistoryPosition = position || 0;\n        this.sessionStorage.setItem(\n          PHX_LV_HISTORY_POSITION,\n          this.currentHistoryPosition.toString()\n        );\n        dom_default.dispatchEvent(window, \"phx:navigate\", {\n          detail: {\n            href,\n            patch: navType === \"patch\",\n            pop: true,\n            direction: isForward ? \"forward\" : \"backward\"\n          }\n        });\n        this.requestDOMUpdate(() => {\n          const callback = () => {\n            this.maybeScroll(scroll);\n          };\n          if (this.main.isConnected() && navType === \"patch\" && id === this.main.id) {\n            this.main.pushLinkPatch(event, href, null, callback);\n          } else {\n            this.replaceMain(href, null, callback);\n          }\n        });\n      },\n      false\n    );\n    window.addEventListener(\n      \"click\",\n      (e) => {\n        const target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        const type = target && target.getAttribute(PHX_LIVE_LINK);\n        if (!type || !this.isConnected() || !this.main || dom_default.wantsNewTab(e)) {\n          return;\n        }\n        const href = target.href instanceof SVGAnimatedString ? target.href.baseVal : target.href;\n        const linkState = target.getAttribute(PHX_LINK_STATE);\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        if (this.pendingLink === href) {\n          return;\n        }\n        this.requestDOMUpdate(() => {\n          if (type === \"patch\") {\n            this.pushHistoryPatch(e, href, linkState, target);\n          } else if (type === \"redirect\") {\n            this.historyRedirect(e, href, linkState, null, target);\n          } else {\n            throw new Error(\n              `expected ${PHX_LIVE_LINK} to be \"patch\" or \"redirect\", got: ${type}`\n            );\n          }\n          const phxClick = target.getAttribute(this.binding(\"click\"));\n          if (phxClick) {\n            this.requestDOMUpdate(() => this.execJS(target, phxClick, \"click\"));\n          }\n        });\n      },\n      false\n    );\n  }\n  maybeScroll(scroll) {\n    if (typeof scroll === \"number\") {\n      requestAnimationFrame(() => {\n        window.scrollTo(0, scroll);\n      });\n    }\n  }\n  dispatchEvent(event, payload = {}) {\n    dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });\n  }\n  dispatchEvents(events) {\n    events.forEach(([event, payload]) => this.dispatchEvent(event, payload));\n  }\n  withPageLoading(info, callback) {\n    dom_default.dispatchEvent(window, \"phx:page-loading-start\", { detail: info });\n    const done = () => dom_default.dispatchEvent(window, \"phx:page-loading-stop\", { detail: info });\n    return callback ? callback(done) : done;\n  }\n  pushHistoryPatch(e, href, linkState, targetEl) {\n    if (!this.isConnected() || !this.main.isMain()) {\n      return browser_default.redirect(href);\n    }\n    this.withPageLoading({ to: href, kind: \"patch\" }, (done) => {\n      this.main.pushLinkPatch(e, href, targetEl, (linkRef) => {\n        this.historyPatch(href, linkState, linkRef);\n        done();\n      });\n    });\n  }\n  historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {\n    if (!this.commitPendingLink(linkRef)) {\n      return;\n    }\n    this.currentHistoryPosition++;\n    this.sessionStorage.setItem(\n      PHX_LV_HISTORY_POSITION,\n      this.currentHistoryPosition.toString()\n    );\n    browser_default.updateCurrentState((state) => ({ ...state, backType: \"patch\" }));\n    browser_default.pushState(\n      linkState,\n      {\n        type: \"patch\",\n        id: this.main.id,\n        position: this.currentHistoryPosition\n      },\n      href\n    );\n    dom_default.dispatchEvent(window, \"phx:navigate\", {\n      detail: { patch: true, href, pop: false, direction: \"forward\" }\n    });\n    this.registerNewLocation(window.location);\n  }\n  historyRedirect(e, href, linkState, flash, targetEl) {\n    const clickLoading = targetEl && e.isTrusted && e.type !== \"popstate\";\n    if (clickLoading) {\n      targetEl.classList.add(\"phx-click-loading\");\n    }\n    if (!this.isConnected() || !this.main.isMain()) {\n      return browser_default.redirect(href, flash);\n    }\n    if (/^\\/$|^\\/[^\\/]+.*$/.test(href)) {\n      const { protocol, host } = window.location;\n      href = `${protocol}//${host}${href}`;\n    }\n    const scroll = window.scrollY;\n    this.withPageLoading({ to: href, kind: \"redirect\" }, (done) => {\n      this.replaceMain(href, flash, (linkRef) => {\n        if (linkRef === this.linkRef) {\n          this.currentHistoryPosition++;\n          this.sessionStorage.setItem(\n            PHX_LV_HISTORY_POSITION,\n            this.currentHistoryPosition.toString()\n          );\n          browser_default.updateCurrentState((state) => ({\n            ...state,\n            backType: \"redirect\"\n          }));\n          browser_default.pushState(\n            linkState,\n            {\n              type: \"redirect\",\n              id: this.main.id,\n              scroll,\n              position: this.currentHistoryPosition\n            },\n            href\n          );\n          dom_default.dispatchEvent(window, \"phx:navigate\", {\n            detail: { href, patch: false, pop: false, direction: \"forward\" }\n          });\n          this.registerNewLocation(window.location);\n        }\n        if (clickLoading) {\n          targetEl.classList.remove(\"phx-click-loading\");\n        }\n        done();\n      });\n    });\n  }\n  registerNewLocation(newLocation) {\n    const { pathname, search } = this.currentLocation;\n    if (pathname + search === newLocation.pathname + newLocation.search) {\n      return false;\n    } else {\n      this.currentLocation = clone(newLocation);\n      return true;\n    }\n  }\n  bindForms() {\n    let iterations = 0;\n    let externalFormSubmitted = false;\n    this.on(\"submit\", (e) => {\n      const phxSubmit = e.target.getAttribute(this.binding(\"submit\"));\n      const phxChange = e.target.getAttribute(this.binding(\"change\"));\n      if (!externalFormSubmitted && phxChange && !phxSubmit) {\n        externalFormSubmitted = true;\n        e.preventDefault();\n        this.withinOwners(e.target, (view) => {\n          view.disableForm(e.target);\n          window.requestAnimationFrame(() => {\n            if (dom_default.isUnloadableFormSubmit(e)) {\n              this.unload();\n            }\n            e.target.submit();\n          });\n        });\n      }\n    });\n    this.on(\"submit\", (e) => {\n      const phxEvent = e.target.getAttribute(this.binding(\"submit\"));\n      if (!phxEvent) {\n        if (dom_default.isUnloadableFormSubmit(e)) {\n          this.unload();\n        }\n        return;\n      }\n      e.preventDefault();\n      e.target.disabled = true;\n      this.withinOwners(e.target, (view) => {\n        js_default.exec(e, \"submit\", phxEvent, view, e.target, [\n          \"push\",\n          { submitter: e.submitter }\n        ]);\n      });\n    });\n    for (const type of [\"change\", \"input\"]) {\n      this.on(type, (e) => {\n        if (e instanceof CustomEvent && (e.target instanceof HTMLInputElement || e.target instanceof HTMLSelectElement || e.target instanceof HTMLTextAreaElement) && e.target.form === void 0) {\n          if (e.detail && e.detail.dispatcher) {\n            throw new Error(\n              `dispatching a custom ${type} event is only supported on input elements inside a form`\n            );\n          }\n          return;\n        }\n        const phxChange = this.binding(\"change\");\n        const input = e.target;\n        if (this.blockPhxChangeWhileComposing && e.isComposing) {\n          const key = `composition-listener-${type}`;\n          if (!dom_default.private(input, key)) {\n            dom_default.putPrivate(input, key, true);\n            input.addEventListener(\n              \"compositionend\",\n              () => {\n                input.dispatchEvent(new Event(type, { bubbles: true }));\n                dom_default.deletePrivate(input, key);\n              },\n              { once: true }\n            );\n          }\n          return;\n        }\n        const inputEvent = input.getAttribute(phxChange);\n        const formEvent = input.form && input.form.getAttribute(phxChange);\n        const phxEvent = inputEvent || formEvent;\n        if (!phxEvent) {\n          return;\n        }\n        if (input.type === \"number\" && input.validity && input.validity.badInput) {\n          return;\n        }\n        const dispatcher = inputEvent ? input : input.form;\n        const currentIterations = iterations;\n        iterations++;\n        const { at, type: lastType } = dom_default.private(input, \"prev-iteration\") || {};\n        if (at === currentIterations - 1 && type === \"change\" && lastType === \"input\") {\n          return;\n        }\n        dom_default.putPrivate(input, \"prev-iteration\", {\n          at: currentIterations,\n          type\n        });\n        this.debounce(input, e, type, () => {\n          this.withinOwners(dispatcher, (view) => {\n            dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);\n            js_default.exec(e, \"change\", phxEvent, view, input, [\n              \"push\",\n              { _target: e.target.name, dispatcher }\n            ]);\n          });\n        });\n      });\n    }\n    this.on(\"reset\", (e) => {\n      const form = e.target;\n      dom_default.resetForm(form);\n      const input = Array.from(form.elements).find((el) => el.type === \"reset\");\n      if (input) {\n        window.requestAnimationFrame(() => {\n          input.dispatchEvent(\n            new Event(\"input\", { bubbles: true, cancelable: false })\n          );\n        });\n      }\n    });\n  }\n  debounce(el, event, eventType, callback) {\n    if (eventType === \"blur\" || eventType === \"focusout\") {\n      return callback();\n    }\n    const phxDebounce = this.binding(PHX_DEBOUNCE);\n    const phxThrottle = this.binding(PHX_THROTTLE);\n    const defaultDebounce = this.defaults.debounce.toString();\n    const defaultThrottle = this.defaults.throttle.toString();\n    this.withinOwners(el, (view) => {\n      const asyncFilter = () => !view.isDestroyed() && document.body.contains(el);\n      dom_default.debounce(\n        el,\n        event,\n        phxDebounce,\n        defaultDebounce,\n        phxThrottle,\n        defaultThrottle,\n        asyncFilter,\n        () => {\n          callback();\n        }\n      );\n    });\n  }\n  silenceEvents(callback) {\n    this.silenced = true;\n    callback();\n    this.silenced = false;\n  }\n  on(event, callback) {\n    this.boundEventNames.add(event);\n    window.addEventListener(event, (e) => {\n      if (!this.silenced) {\n        callback(e);\n      }\n    });\n  }\n  jsQuerySelectorAll(sourceEl, query, defaultQuery) {\n    const all = this.domCallbacks.jsQuerySelectorAll;\n    return all ? all(sourceEl, query, defaultQuery) : defaultQuery();\n  }\n};\nvar TransitionSet = class {\n  constructor() {\n    this.transitions = /* @__PURE__ */ new Set();\n    this.promises = /* @__PURE__ */ new Set();\n    this.pendingOps = [];\n  }\n  reset() {\n    this.transitions.forEach((timer) => {\n      clearTimeout(timer);\n      this.transitions.delete(timer);\n    });\n    this.promises.clear();\n    this.flushPendingOps();\n  }\n  after(callback) {\n    if (this.size() === 0) {\n      callback();\n    } else {\n      this.pushPendingOp(callback);\n    }\n  }\n  addTransition(time, onStart, onDone) {\n    onStart();\n    const timer = setTimeout(() => {\n      this.transitions.delete(timer);\n      onDone();\n      this.flushPendingOps();\n    }, time);\n    this.transitions.add(timer);\n  }\n  addAsyncTransition(promise) {\n    this.promises.add(promise);\n    promise.then(() => {\n      this.promises.delete(promise);\n      this.flushPendingOps();\n    });\n  }\n  pushPendingOp(op) {\n    this.pendingOps.push(op);\n  }\n  size() {\n    return this.transitions.size + this.promises.size;\n  }\n  flushPendingOps() {\n    if (this.size() > 0) {\n      return;\n    }\n    const op = this.pendingOps.shift();\n    if (op) {\n      op();\n      this.flushPendingOps();\n    }\n  }\n};\n\n// js/phoenix_live_view/index.ts\nvar LiveSocket2 = LiveSocket;\nfunction createHook(el, callbacks) {\n  let existingHook = dom_default.getCustomElHook(el);\n  if (existingHook) {\n    return existingHook;\n  }\n  let hook = new ViewHook(View.closestView(el), el, callbacks);\n  dom_default.putCustomElHook(el, hook);\n  return hook;\n}\n\n//# sourceMappingURL=phoenix_live_view.esm.js.map\n\n\n//# sourceURL=webpack://starweave_web/../../../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js?\n}");

/***/ }),

/***/ "./css/app.css":
/*!*********************!*\
  !*** ./css/app.css ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://starweave_web/./css/app.css?\n}");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.css */ \"./css/app.css\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix */ \"../../../deps/phoenix/priv/static/phoenix.mjs\");\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix_live_view */ \"../../../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! phoenix_html */ \"../../../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_3__);\n// We import the CSS which is extracted to its own file by esbuild.\n// See the CSS config in your config/config.exs.\n\n\n// Import Phoenix and LiveView\n\n\n\n\n// LiveView Hooks\nconst Hooks = {\n  AutoResize: {\n    mounted() { this.resize() },\n    updated() { this.resize() },\n    resize() {\n      const el = this.el\n      if (!el) return\n      if (el.tagName && el.tagName.toLowerCase() === 'textarea') {\n        try {\n          el.style.height = 'auto'\n          el.style.height = `${el.scrollHeight}px`\n        } catch (e) {\n          console.error(\"AutoResize hook error:\", e)\n        }\n      }\n    }\n  }\n}\n\n// Wait for the DOM to be fully loaded before initializing LiveView\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  // Get CSRF token\n  const csrfToken = document.querySelector(\"meta[name='csrf-token']\")?.getAttribute(\"content\")\n\n  if (!csrfToken) {\n    console.error(\"CSRF token not found. LiveView will not be available.\")\n    return\n  }\n\n  try {\n    // Initialize LiveView with the Phoenix Socket constructor (not an instance)\n    const liveSocket = new phoenix_live_view__WEBPACK_IMPORTED_MODULE_2__.LiveSocket(\"/live\", phoenix__WEBPACK_IMPORTED_MODULE_1__.Socket, {\n      params: {_csrf_token: csrfToken},\n      hooks: Hooks,\n      dom: {\n        onBeforeElUpdated(from, to) {\n          if (from._x_dataStack) {\n            try {\n              window.Alpine && window.Alpine.clone(from, to)\n            } catch (e) {\n              console.error(\"Alpine clone error:\", e)\n            }\n          }\n        }\n      }\n    })\n\n    // Connect to LiveView\n    liveSocket.connect()\n\n    // Expose liveSocket on window for debugging\n    window.liveSocket = liveSocket\n\n    // Handle page loading events\n    window.addEventListener(\"phx:page-loading-start\", () => {\n      const loadingIndicator = document.getElementById(\"loading-indicator\")\n      if (loadingIndicator) {\n        try { loadingIndicator.classList.remove(\"hidden\") } catch {}\n      }\n    })\n\n    window.addEventListener(\"phx:page-loading-stop\", () => {\n      const loadingIndicator = document.getElementById(\"loading-indicator\")\n      if (loadingIndicator) {\n        try { loadingIndicator.classList.add(\"hidden\") } catch {}\n      }\n\n      // Auto-scroll to bottom of message container\n      const messageContainer = document.querySelector(\".message-container\")\n      if (messageContainer) {\n        try { messageContainer.scrollTop = messageContainer.scrollHeight } catch {}\n      }\n    })\n\n    // Auto-resize textarea\n    document.addEventListener(\"input\", function(e) {\n      if (e.target && e.target.matches(\"textarea\")) {\n        try {\n          e.target.style.height = 'auto'\n          e.target.style.height = (e.target.scrollHeight) + 'px'\n        } catch (e) {\n          console.error(\"Error resizing textarea:\", e)\n        }\n      }\n    })\n\n    // Handle LiveView updates\n    window.addEventListener(\"phx:update\", () => {\n      const messageContainer = document.querySelector(\".message-container\")\n      if (messageContainer) {\n        try { messageContainer.scrollTop = messageContainer.scrollHeight } catch {}\n      }\n    })\n\n    console.log(\"LiveView initialized successfully\")\n  } catch (error) {\n    console.error(\"Error initializing LiveView:\", error)\n  }\n})\n\n// Realtime: Phoenix Channels basic wire-up\ntry {\n  const socket = new phoenix__WEBPACK_IMPORTED_MODULE_1__.Socket(\"/socket\", { params: { user_id: \"anon\" } })\n  socket.connect()\n  const channel = socket.channel(\"pattern:lobby\", {})\n\n  channel.join()\n    .receive(\"ok\", resp => {\n      console.log(\"Joined pattern:lobby\", resp)\n      channel.push(\"ping\", { hello: \"world\" })\n        .receive(\"ok\", resp => console.log(\"ping ok:\", resp))\n        .receive(\"error\", err => console.error(\"ping error:\", err))\n    })\n    .receive(\"error\", resp => console.error(\"Join failed\", resp))\n    .receive(\"timeout\", () => console.error(\"Join timeout\"))\n\n  channel.on(\"pattern_recognized\", payload => {\n    console.log(\"pattern_recognized:\", payload)\n  })\n\n  channel.on(\"pattern_learned\", payload => {\n    console.log(\"pattern_learned:\", payload)\n  })\n\n  window.starweaveSocket = socket\n  window.starweaveChannel = channel\n} catch (e) {\n  console.error(\"Error wiring Phoenix Channels:\", e)\n}\n\n\n//# sourceURL=webpack://starweave_web/./js/app.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./js/app.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./css/app.css");
/******/ 	
/******/ })()
;